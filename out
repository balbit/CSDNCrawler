Title
----------------
为什么是 Dart ?
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/122952769
================
Stars
----------------
1
================
Header
----------------
为什么是 Dart ?
================
Text
----------------
为什么选择Dart语言，这是很多人的疑问，让我们先来看看，最近Dart 编程语言的发展情况：
2022年2月TIOBE编程语言排行榜：
很遗憾，Dart在前20名之外，但好消息是它还处于前30名之内！
在这个排行榜中，值得我们注意的是Dart语言仍然处于Kotlin之上，虽然优势并不明显。让我们再来看一看 IEEE Spectrum 最新发布的2021年度的编程语言排行榜 Top Programming Languages 2021
在IEEE Spectrum 的榜单中，Dart 处于第14位，并且与Kotlin拉开了更多差距。这份榜单是以2021整个年度来衡量的，显然比TIOBE的排名更均衡。另外，TIOBE的排名主要参考当月搜索引擎的搜索热度，这有点类似于热搜排名。而IEEE Spectrum 的榜单除了参考热搜，还要参考Github的仓库数量，一些技术论坛的发帖数量等等，因此IEEE Spectrum榜单更能衡量一门编程语言的生态情况。
总而言之，Dart语言仍然是极具潜力的一门编程语言，非常值得学习。
有部分人曾在我面前极力吹捧Kotlin语言，给了我Kotlin远超Dart语言的感觉，但我们回到大数据面前，Kotlin的热度似乎还赶不上Dart，真是让人情何以堪呐…更何况同为JVM语言，Kotlin可以直接使用Java的库，它直接借助Java庞大的生态，发展得也不过如此。
事实上，我不是编程语言宗教的信奉者，在我眼里没有谁是最好的语言，只有最合适的语言。我信奉的是工具论，每种编程语言都是一种工具，是人来主导工具，而不是人被工具主宰！我理解最完美的状态，是干什么活，就用什么工具，而不是因为我手上只有这把锤子，所以看什么都是钉子。
作为一个跨平台的移动开发者，Kotlin也好，Swift也好，都是需要学习的，如果有人固执的认为，学一种就够了，一招鲜吃遍天，那么他说不定什么时候就得踩一个大坑。
好了，现在让我们回到一开始的问题，Flutter为什么选择了Dart语言，我们为什么要拥抱 Dart 语言？
================
Header
----------------
背景
================
Text
----------------
从历史上看，计算机语言被分为两类：静态语言（例如Fortran 或 C，其中变量在编译时静态类型化）和动态语言（例如，Smalltalk 或 JavaScript，其中变量的类型可以在运行时改变）。静态语言通常被编译为目标机器的本地机器码（或汇编代码），这些程序在运行时由硬件直接执行。动态语言由解释器执行，不产生机器码。
当然，事情最终变得更加复杂。虚拟机（VM）的概念变得流行起来，它实际上只是一种在软件中模仿硬件机器的高级解释器。虚拟机使得将一种语言移植到新的硬件平台变得更加容易。在这种情况下，VM 的输入语言通常是一种中间语言。例如Java语言被编译成一种中间语言（字节码），然后在虚拟机（JVM）上执行。那么虚拟机和解释器之间有什么区别呢？简单说，解释器是直接解释执行编程语言的源代码，这些源代码是字符串；虚拟机解释执行的是由源代码翻译之后生成的字节码，这些字节码是二进制，但同时，这些字节码并不是真正的机器码，不能被任何硬件直接理解执行。
此外，现在还有即时(JIT) 编译器。JIT 编译器在程序运行期间执行编译，因此称为即时编译。在程序创建期间（编写完源代码）进行原始编译的编译器现在称为提前(AOT) 编译器。
一般来说，只有静态语言适合 AOT 编译为本机机器码，因为机器语言通常需要知道数据的类型，而在动态语言中，类型并没有提前固定。因此，动态语言通常被解释或 JIT 编译。
在开发过程中完成 AOT 编译时，总是会导致开发周期变慢（从对程序进行修改到能够执行程序以查看修改结果之间的时间）。但是 AOT 编译导致程序可以更可预测地执行，并且在运行时无需暂停分析和编译。AOT 编译的程序也执行得更快（因为它们提前就被编译好了）。
JIT 编译可以提供更快的开发周期，但会导致执行速度变慢或不稳定。特别是，JIT 编译器的启动时间较慢，因为当程序开始运行时，JIT 编译器必须先进行分析和编译，然后才能执行代码。
如上图，早期直接由虚拟机这个软件去解释执行字节码性能较差，为了解决这个问题，就提出了JIT编译。JIT编译就是在虚拟机这个软件中再内置一个编译器，当用户运行Java编写的程序时，虚拟机会对字节码进行分析，对于频繁执行，且比较耗费性能的部分代码，就由JIT编译器在运行时将其编译成机器码，这样就可以将这部分直接交给CPU来执行，提升性能。因此，支持JIT编译的虚拟机，首次运行程序可能会更慢，因此它在运行时还要进行编译工作。有人可能会说，既然如此，为什么不在运行之前，就将所有代码编译成机器码，运行时直接交给CPU执行，这样不就速度更快了吗？是的，这就是AOT！
================
Header
----------------
Dart
================
Text
----------------
2011 年 10 月 10 日，谷歌的两名工程师在 GOTO 会议上推出了“ Dart ”，作为一种全新的编程语言，旨在帮助开发人员构建 Web 应用程序。Dart 1.0 于 2013 年 11 月 14 日发布。
在开发 Dart 之前，Dart 团队成员在高级编译器和虚拟机方面做了开创性的工作，包括动态语言（如用于 JavaScript的V8 引擎和用于 Smalltalk 的Strongtalk ）和静态语言（如用于 Java的Hotspot 编译器）。他们利用这一经验使 Dart 在编译和执行方面异常灵活。
Dart 是极少数非常适合同时编译 AOT 和 JIT 的语言之一。支持这两种编译为 Dart 和（尤其是）Flutter 提供了显着的优势。
在开发过程中使用 JIT 编译，使用速度特别快的编译器。然后，当应用程序准备好发布给用户使用时，它会被编译为 AOT。因此，借助先进的工具和编译器，Dart 可以实现两全其美：极快的开发周期，以及快速的执行和启动时间。
Dart 在编译和执行方面的灵活性并不止于此。例如，Dart 可以编译成 JavaScript，以便浏览器执行。这允许在移动应用程序和 Web 应用程序之间重用代码。开发人员报告称，他们的移动和 Web 应用程序之间的代码重用率高达 70% 。Dart 也可以通过编译为本机代码或编译为 JavaScript 并与node.js一起使用来在服务器上使用。
最后，Dart 还提供了一个独立的 VM。
结论：Dart 可以高效地编译 AOT 或 JIT、解释或转译成其他语言。Dart 不仅编译和执行异常灵活，而且速度特别快。
================
Header
----------------
学习Dart的理由
================
Text
----------------
使用 Dart 和 Flutter 编写的移动应用程序是跨平台的原生应用程序；因此它们可以在 Android、iOS、Windows、Linux、MacOS上运行。甚至可以编写 Web 应用程序，让代码在浏览器上运行。从开发人员的角度来看，语言的灵活性和可移植性非常重要。毕竟，谁不想编写一些代码并在尽可能多的平台上运行呢？
一旦你熟悉了面向对象的一般原则，在 Dart 中编码就会感觉很自然。Javascript 遵循无类型哲学，因为根据 JS，无类型意味着灵活性。但是开发人员经常说，过多的灵活性会扼杀你的软件。有时你想使用类型，而有时则不想。有了 Dart，你可以做到两全其美。
Dart 很容易学习。Dart 语法看起来非常熟悉，即使是第一眼。哪怕你之前没有看过 Dart 代码，也可以轻松理解它而不会费力。Dart 语言结构良好，因此如果你已经了解 C、Java 、JavaScript或 C#等任意一门编程语言，那么 Dart 上手将非常容易。
Dart 有很好的工具支持，确保了生产力。除了各种静态工具，它有一个现代化的仓库——pub，可以很容易的依赖我们需要的第三方库，也可以很方便的发布我们开源的库。
Dart 是一种健壮的语言。Dart 是一种开源、面向对象、可选类型和基于类的语言，它对函数式编程和响应式编程具有出色的支持。与 Java 不同，Dart 一点也不臃肿。事实上，它是一种相对简单、现代且高效的类似于 C 的编译语言，它在2.12之后发布的空安区特性，极大的提升了代码的健壮性。
除了Dart本身的优秀特性，学习Dart语言最核心的理由，当然是为了Flutter！Flutter是一种极为优秀的跨平台UI框架，并且是谷歌最新的 Fuchsia 操作系统默认的App开发框架，而Dart也是Fuchsia系统默认的几种开发语言之一，可以说，Dart未来的潜力巨大。
懒惰是人类的天性，我能理解为什么有编程语言宗教。许多人因为工作的关系，业务的驱动，好不容易从Java语言切换到kotlin语言，结果现在来了Flutter，又要学一门Dart语言，Kotlin语言都还没捂热了，又要学，第一感触就是反感抵触。老实说，我第一次接触Flutter和Dart就非常排斥，即使我已经会写Java、JavaScript、Python、Go等一些语言，并且正在学习Kotlin，但是我仍然不太情愿为了用一用Flutter再学一种编程语言。为了Flutter，我决定一试，结果让我感觉非常好。当人们批评Java的冗余繁琐，大谈Kotlin简化代码提升生产力时，我反而觉得Java的那些痛点都被Dart解决了，我个人感觉Dart可能比Kotlin更加简洁。
如果我因为拖延症或其他原因，不想学习某种技术时，或许我也会拼命抵制它，搜遍互联网，找到所有的负面理由贬低它，并且大声疾呼，我使用的这种编程语言已经足够好了，它是我手上的锤子，它能解决一切问题！找遍了理由和黑点，可能起因只是因为懒得学而已。但我们知道这没有意义，不如开放胸怀，去拥抱变化。
切换新的语言和技术栈就像搬家，人们都很讨厌，很讨厌折腾，我们总是希望这是最后一次了，但往往可能还有很多次！如果我们总是这样想，只会收获一个糟糕的心情。曾经有网友说过一句话，编程语言对程序员来说就像女朋友，不同的是，程序员玩腻了总能换一门新的，这样，程序员的生活总是充满新鲜感！这话虽然很粗糙，但是Linus Torvalds也讲过，“大多数优秀的程序员做编程不是因为他们期望得到报酬或得到公众的奉承，而是因为编程很有趣。”
所以，学会享受！
最后送给大家一首 Dart 之诗：
When playing darts, it is agreed,
A steady hand is what you need.
A good eye and a perfect stance.
(For darts is not a game of chance!)
关注公众号：编程之路从0到1
================
Title
----------------
从事Cloud行业需要掌握的基本技能清单
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/46059049
================
Stars
----------------
1
================
Text
----------------
从事Cloud行业需要掌握的基本技能清单如下，
有Openstack，Cloudstack开发经验者优先；
================
Title
----------------
Web开发：MVC
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_56886142/article/details/126982803
================
Stars
----------------
83
================
Header
----------------
MVC
================
Header
----------------
概述
================
Text
----------------
设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。而MVC（Model View Controller，模型-视图-控制器）是JavaWeb中常用的一种设计模式，用于应用程序的分层开发——将封装数据的模型、显示用户界面的视图、协调调度的控制器分开，实现各个组件耦合降低与单独维护，方便于前后端对接。
MVC设计模式与MVC框架的区别： 打个比方，MVC设计模式是设计师手中的图纸；MVC框架是工程师以设计师的图纸建造出来的产品。MVC一般指的是MVC框架。
其中，MVC（Model View Controlle
================
Title
----------------
今天一口气写了5篇博文，不错，写篇文章纪念一下！！
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/42132741
================
Stars
----------------
0
================
Text
----------------
好不用等到公司放了9天圣诞假，眼看假期已经过去一半了，趁着今天外面天气污染比较严重。在家里写了几篇有关于Eclipse Plugin相关的博文。写篇博文，鼓励和激励自己一下。
自己经常在思考一个问题，其实做一个好的程序员不难，但是做一个沟通好的程序员却不容易；其中沟通好的一个很重要的方面就是自己能够把自己学到的东西，记录下来；并且能够很清楚的表达出来，这个时候就要靠自己的笔杆子了。
只有自己经常的写，才能妙笔生花。这让我想起了一个故事，讲的是书法家王献之的一个故事：有一次王献之对其父亲王羲之说，“父亲，我也要成为像你一样的书法家,不知道有没有什么捷径". 王献之的父亲，王羲之说，”你只要把咱们家后院的20缸的水，全部用完来写书法，你肯定就有所成就。“ 最终，王献之也成为了一个伟大的书法家而千古流芳。虽然这个故事有点糙，但是道理不糙。
其实有的时候，自己写技术博文，完全是心血来潮，突然感觉自己有点时间了，打开CSDN写一篇博文。但是大多数的时候，因为工作上比较忙的原因，要不是没有时间捉笔，要不是下班后，比较累，根本上就不想写任何的东西。因此，作者突然心血来潮，写一遍博文，一遍是来纪念一下今天的收获，另外一方面以此文章来鞭策和激励自己，坚持，坚持，在坚持。。。。。。。。
================
Title
----------------
保密通信协议
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/algzjh/article/details/63713796
================
Stars
----------------
1
================
Header
----------------
1、算法分类
================
Text
----------------
（1）密码算法是否保密
（2）加解密钥是否相同
公钥密码算法（ECC，RSA）
一个在线的加密解密网站：http://tool.chacuo.net/cryptaes
================
Header
----------------
2、保密通信协议的流程
================
Text
----------------
（1）通信双方协商密码算法和密钥  （2）发送者将明文m加密成密文c  （3）发送者发送密文消息c  （4）接受者对密文c解密获得明文m
================
Header
----------------
3、采用对称密码算法
================
Text
----------------
引入TTP（Trusted Third Party，可信任第三方），用户张三，李四和TTP共享密钥ka和kb，TTP易形成瓶颈
================
Header
----------------
4、采用公钥密码算法
================
Text
----------------
张三用李四（私钥为
kBv
）的公钥
kBp
加密消息  张三——>
EBp(m)
——>李四
================
Header
----------------
5、交换公钥的中间人攻击
================
Text
----------------
当张三和李四互传公钥时，黑客截获，用自己的公钥取代，从而能用私钥解密双方传送的消息。  如何避免中间人攻击：数字证书
================
Header
----------------
6、混合密码通信
================
Text
----------------
对称密码加密消息，提高加解密速度  公钥密码算法协商会话密钥，简化密钥管理  张三明文m——>
Ek(m)
——>李四明文m  共享密钥k——>
EBk(k)
——>共享密钥k  网络保密通信的典型应用：数字信封  特点：速度快，密钥管理简单，安全性依赖于公钥的可靠
================
Title
----------------
Flutter 安卓平台源码剖析（一）
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/100543916
================
Stars
----------------
10
================
Header
----------------
文章目录
================
Text
----------------
博主相关文章列表 Flutter 框架实现原理 Flutter 框架层启动源码剖析 Flutter 页面更新流程剖析 Flutter 事件处理源码剖析 Flutter 路由源码剖析 Flutter 安卓平台源码剖析（一） Flutter 自定义控件之RenderObject
================
Header
----------------
前言
================
Text
----------------
做技术，只有弄懂了原理，才能遇事不慌，手中无码，心中有码。这篇文章主要研究Flutter 在安卓平台上的启动流程源码。
================
Header
----------------
启动流程
================
Header
----------------
入口Activity
================
Text
----------------
当我们创建一个Flutter app工程时，打开android目录下的源码，会发现有一个MainActivity继承自FlutterActivity，整个MainActivity非常简单，只在onCreate下加了一行代码GeneratedPluginRegistrant.registerWith(this)，那么FlutterActivity又是何方神圣呢？FlutterActivity的源码在Flutter SDK的jar包中，想要研究Flutter源码，第一件事就是需要下载一套SDK源码，我们可以在GitHub上下载 engine源码
================
Code
----------------
public class MainActivity extends FlutterActivity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    GeneratedPluginRegistrant.registerWith(this);
  }
}
================
Text
----------------
engine\src\flutter\shell\platform\android\io\flutter\app\FlutterActivity.java 省略部分源码，删除注释后代码如下
================
Code
----------------
public class FlutterActivity extends Activity implements 
FlutterView.Provider, PluginRegistry, ViewFactory {
    private static final String TAG = "FlutterActivity";
    
    private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);

    private final FlutterActivityEvents eventDelegate = delegate;
    private final FlutterView.Provider viewProvider = delegate;
    private final PluginRegistry pluginRegistry = delegate;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        eventDelegate.onCreate(savedInstanceState);
    }

    @Override
    protected void onStart() {
        super.onStart();
        eventDelegate.onStart();
    }

    @Override
    protected void onResume() {
        super.onResume();
        eventDelegate.onResume();
    }

    @Override
    protected void onDestroy() {
        eventDelegate.onDestroy();
        super.onDestroy();
    }

   // ...省略部分源码...
}
================
Text
----------------
可以看到FlutterActivity继承自Activity，并实现了三个接口，FlutterActivity的生命周期方法，均由一个代理类FlutterActivityDelegate处理。
engine\src\flutter\shell\platform\android\io\flutter\app\FlutterActivityDelegate.java
================
Code
----------------
@Override
    public void onCreate(Bundle savedInstanceState) {
        // 根据当前系统版本设置沉浸式状态栏
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            Window window = activity.getWindow();
            window.addFlags(LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
            window.setStatusBarColor(0x40000000);
            window.getDecorView().setSystemUiVisibility(PlatformPlugin.DEFAULT_SYSTEM_UI);
        }
        // 获取intent传入的参数信息
        String[] args = getArgsFromIntent(activity.getIntent());
        // 初始化一些参数配置信息，包括打包的flutter代码路径、应用存储目录、引擎缓存目录等
        FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), args);
        
        flutterView = viewFactory.createFlutterView(activity);
        // 真正创建contentView的地方
        if (flutterView == null) {
            FlutterNativeView nativeView = viewFactory.createFlutterNativeView();
            flutterView = new FlutterView(activity, null, nativeView);
            flutterView.setLayoutParams(matchParent);
            activity.setContentView(flutterView);
            launchView = createLaunchView();
            if (launchView != null) {
                addLaunchView();
            }
        }

        if (loadIntent(activity.getIntent())) {
            return;
        }

        String appBundlePath = FlutterMain.findAppBundlePath(activity.getApplicationContext());
        if (appBundlePath != null) {
            runBundle(appBundlePath);
        }
    }
================
Text
----------------
我们自然是要找到onCreate方法，以上代码我增加了一点注释，我们要快速定位到关键代码，什么是关键代码，看到了activity.setContentView(flutterView);，这里就是关键代码，终于见到了我们熟悉的setContentView了。这里我们不禁要问，这个flutterView到底是个什么View?
一开始我们就知道ViewFactory是FlutterActivity实现的，这里createFlutterView方法实现也在FlutterActivity里，但这个方法始终返回空，再看createFlutterNativeView方法，仍然是返回空
================
Code
----------------
@Override
    public FlutterNativeView createFlutterNativeView() {
        return null;
    }
    
    @Override
    public FlutterNativeView createFlutterNativeView() {
        return null;
    }
================
Text
----------------
这里真正的flutterView实际上是通过flutterView = new FlutterView(activity, null, nativeView)这行代码new出来的，然后传递给setContentView
接下来直接看到FlutterView源码（省略部分代码）
================
Code
----------------
public class FlutterView extends SurfaceView implements BinaryMessenger, TextureRegistry {
    private static final String TAG = "FlutterView";

    public FlutterView(Context context, AttributeSet attrs, FlutterNativeView nativeView) {
        super(context, attrs);

        Activity activity = getActivity(getContext());
        if (activity == null) {
            throw new IllegalArgumentException("Bad context");
        }

        if (nativeView == null) {
            mNativeView = new FlutterNativeView(activity.getApplicationContext());
        } else {
            mNativeView = nativeView;
        }

        dartExecutor = mNativeView.getDartExecutor();
        flutterRenderer = new FlutterRenderer(mNativeView.getFlutterJNI());
        mIsSoftwareRenderingEnabled = FlutterJNI.nativeGetIsSoftwareRenderingEnabled();
        mMetrics = new ViewportMetrics();
        mMetrics.devicePixelRatio = context.getResources().getDisplayMetrics().density;
        setFocusable(true);
        setFocusableInTouchMode(true);

        mNativeView.attachViewAndActivity(this, activity);

        mSurfaceCallback = new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                assertAttached();
                mNativeView.getFlutterJNI().onSurfaceCreated(holder.getSurface());
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                assertAttached();
                mNativeView.getFlutterJNI().onSurfaceChanged(width, height);
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                assertAttached();
                mNativeView.getFlutterJNI().onSurfaceDestroyed();
            }
        };
        getHolder().addCallback(mSurfaceCallback);

        mActivityLifecycleListeners = new ArrayList<>();
        mFirstFrameListeners = new ArrayList<>();

        // Create all platform channels
        navigationChannel = new NavigationChannel(dartExecutor);
        keyEventChannel = new KeyEventChannel(dartExecutor);
        lifecycleChannel = new LifecycleChannel(dartExecutor);
        localizationChannel = new LocalizationChannel(dartExecutor);
        platformChannel = new PlatformChannel(dartExecutor);
        systemChannel = new SystemChannel(dartExecutor);
        settingsChannel = new SettingsChannel(dartExecutor);

        // Create and setup plugins
        PlatformPlugin platformPlugin = new PlatformPlugin(activity, platformChannel);
        addActivityLifecycleListener(platformPlugin);
        mImm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        mTextInputPlugin = new TextInputPlugin(this, dartExecutor);
        androidKeyProcessor = new AndroidKeyProcessor(keyEventChannel, mTextInputPlugin);
        androidTouchProcessor = new AndroidTouchProcessor(flutterRenderer);

        // Send initial platform information to Dart
        sendLocalesToDart(getResources().getConfiguration());
        sendUserPlatformSettingsToDart();
    }
================
Text
----------------
到这里就明白了，FlutterView实际上就是安卓中的SurfaceView，因为SurfaceView是双缓冲的，可以在子线程更新UI，性能高效，因此通常是用来做游戏开发、视频直播。经过简单的源码分析，我们大致能明白Flutter在安卓上的实现方式，整个Flutter开发的app都是在一个Activity中进行渲染的，这就有点像现在前端流行的所谓单页应用。
还个方法中还创建了各种平台插件和platform channel，用于Flutter层和原生代码之间的数据传递。
环境初始化
现在我们再回过头来看一下刚刚漏过的一些代码，看看它们做了些什么事 onCreate函数中有调用FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), args)
================
Code
----------------
/**
     * Blocks until initialization of the native system has completed.
     */
    public static void ensureInitializationComplete(@NonNull Context applicationContext, @Nullable String[] args) {
        if (Looper.myLooper() != Looper.getMainLooper()) {
          throw new IllegalStateException("ensureInitializationComplete must be called on the main thread");
        }
        if (sSettings == null) {
          throw new IllegalStateException("ensureInitializationComplete must be called after startInitialization");
        }
        if (sInitialized) {
            return;
        }
        try {
            sResourceExtractor.waitForCompletion();

            List<String> shellArgs = new ArrayList<>();
            shellArgs.add("--icu-symbol-prefix=_binary_icudtl_dat");

            ApplicationInfo applicationInfo = getApplicationInfo(applicationContext);
            shellArgs.add("--icu-native-lib-path=" + applicationInfo.nativeLibraryDir + File.separator + DEFAULT_LIBRARY);

           // ...省略...

            if (sSettings.getLogTag() != null) {
                shellArgs.add("--log-tag=" + sSettings.getLogTag());
            }

            String appBundlePath = findAppBundlePath(applicationContext);
            String appStoragePath = PathUtils.getFilesDir(applicationContext);
            String engineCachesPath = PathUtils.getCacheDirectory(applicationContext);
            nativeInit(applicationContext, shellArgs.toArray(new String[0]),
                appBundlePath, appStoragePath, engineCachesPath);

            sInitialized = true;
        } catch (Exception e) {
            Log.e(TAG, "Flutter initialization failed.", e);
            throw new RuntimeException(e);
        }
    }
================
Text
----------------
该方法注释已经明确告诉我们，这是一个阻塞的方法，直到底层初始化完成。这意味着该方法执行会影响app的启动速度。总的来说，该方法做了几件事，它保证初始化操作在主线程运行，调用sResourceExtractor.waitForCompletion()完成资源文件的提取工作，拼接所有相关的shellArgs参数，包括intent中的参数，配置dart代码编译产物appBundle路径，应用存储、引擎缓存目录等信息， 最后通过执行nativeInit函数在c++层初始化这些信息
创建 splash view
接下来，还有一个地方值得一说，在创建FlutterView之后，调用了一个createLaunchView方法
================
Code
----------------
private View createLaunchView() {
        if (!showSplashScreenUntilFirstFrame()) {
            return null;
        }
        final Drawable launchScreenDrawable = getLaunchScreenDrawableFromActivityTheme();
        if (launchScreenDrawable == null) {
            return null;
        }
        final View view = new View(activity);
        view.setLayoutParams(matchParent);
        view.setBackground(launchScreenDrawable);
        return view;
    }
================
Text
----------------
这个方法，其实就是在Flutter启动后添加一个splash view。大家知道，在Flutter应用启动之后，会有一小段白屏的时间，之所以会白屏，就是这个方法导致的。目前的解决办法，就是手动添加一个设计好的闪屏页，平滑的过度一下。那么如何修改默认的白屏页，设置我们自己的splash view呢？
================
Code
----------------
private Drawable getLaunchScreenDrawableFromActivityTheme() {
        TypedValue typedValue = new TypedValue();
        if (!activity.getTheme().resolveAttribute(
            android.R.attr.windowBackground,
            typedValue,
            true)) {
            return null;
        }
        if (typedValue.resourceId == 0) {
            return null;
        }
        try {
            return activity.getResources().getDrawable(typedValue.resourceId);
        } catch (NotFoundException e) {
            Log.e(TAG, "Referenced launch screen windowBackground resource does not exist");
            return null;
        }
    }
================
Text
----------------
可以看到，这个Drawable其实是从主题的windowBackground中取的，我们打开app工程中的styles.xml
================
Code
----------------
<style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when Flutter draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
================
Text
----------------
看到，windowBackground其实是指定为launch_background，在drawable文件夹下找到它
================
Code
----------------
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
================
Text
----------------
这里默认背景确实被设置成了白色，并且还友好的给出了一个设置图片的示例，将注释的代码打开，就可以设置自己的splash view
================
Header
----------------
Application启动
================
Text
----------------
我们知道安卓app启动时，首先调用的是Application的onCreate，现在来看一看Flutter应用的Application做了些什么 flutter\shell\platform\android\io\flutter\app\FlutterApplication.java
================
Code
----------------
public class FlutterApplication extends Application {
    @Override
    @CallSuper
    public void onCreate() {
        super.onCreate();
        FlutterMain.startInitialization(this);
    }

    private Activity mCurrentActivity = null;
    public Activity getCurrentActivity() {
        return mCurrentActivity;
    }
    public void setCurrentActivity(Activity mCurrentActivity) {
        this.mCurrentActivity = mCurrentActivity;
    }
}
================
Text
----------------
整个FlutterApplication比较简单，主要调用了FlutterMain.startInitialization(this)开启初始化
================
Code
----------------
public static void startInitialization(@NonNull Context applicationContext, @NonNull Settings settings) {
        if (Looper.myLooper() != Looper.getMainLooper()) {
          throw new IllegalStateException("startInitialization must be called on the main thread");
        }
        // Do not run startInitialization more than once.
        if (sSettings != null) {
          return;
        }

        sSettings = settings;

        long initStartTimestampMillis = SystemClock.uptimeMillis();
        initConfig(applicationContext);
        initAot(applicationContext);
        initResources(applicationContext);

        System.loadLibrary("flutter");
        long initTimeMillis = SystemClock.uptimeMillis() - initStartTimestampMillis;
        nativeRecordStartTimestamp(initTimeMillis);
    }
================
Text
----------------
该方法注释表明，它是用来初始化底层的Flutter 引擎的，主要做了几件事，
================
Header
----------------
Java层与Flutter引擎关联
================
Text
----------------
在FlutterApplication中加载了引擎的so，我们不禁要问，那Flutter引擎又是在哪创建的，怎么与原生Java代码关联起来的呢？
在FlutterView构造方法中创建了FlutterNativeView，看到FlutterNativeView的构造方法
================
Code
----------------
public FlutterNativeView(@NonNull Context context, boolean isBackgroundView) {
        mContext = context;
        mPluginRegistry = new FlutterPluginRegistry(this, context);
        mFlutterJNI = new FlutterJNI();
        mFlutterJNI.setRenderSurface(new RenderSurfaceImpl());
        this.dartExecutor = new DartExecutor(mFlutterJNI);
        mFlutterJNI.addEngineLifecycleListener(new EngineLifecycleListenerImpl());
        attach(this, isBackgroundView);
        assertAttached();
    }
================
Text
----------------
在这里主要创建了FlutterJNI对象，并调用了一个关键方法attach，一路跟踪该方法调用
================
Code
----------------
private void attach(FlutterNativeView view, boolean isBackgroundView) {
        mFlutterJNI.attachToNative(isBackgroundView);
        dartExecutor.onAttachedToJNI();
    }
================
Text
----------------
flutter\shell\platform\android\io\flutter\embedding\engine\FlutterJNI.java
================
Code
----------------
public void attachToNative(boolean isBackgroundView) {
    ensureRunningOnMainThread();
    ensureNotAttachedToNative();
    nativePlatformViewId = nativeAttach(this, isBackgroundView);
  }
  
  private native long nativeAttach(FlutterJNI flutterJNI, boolean isBackgroundView);
================
Text
----------------
最后发现调用了一个native方法，并将FlutterJNI实例对象自身传入了C++层。这里，我们怎么才能找到native方法所对应的C++源码呢？
我这里就介绍一种最简单的傻瓜式方法，不需要太多技巧，大家可以下载一个FileLocatorPro工具，它是Windows平台上的文本搜索神器，建议最好安装一个。  为了搜索更快，我们不仅仅将下载的Flutter engine源码根路径设置进去，还要缩写一点范围，我这里将源码根目录下的flutter\shell\platform\android设置为搜索路径，另外还可以在文件名称一栏填入*.cc，表示仅搜索以.cc作为后缀的文件，这里.cc是C++源文件后缀名。最后我们秒搜到了匹配的内容
flutter\shell\platform\android\platform_view_android_jni.cc
================
Code
----------------
static const JNINativeMethod flutter_jni_methods[] = {
      // Start of methods from FlutterNativeView
      {
          .name = "nativeAttach",
          .signature = "(Lio/flutter/embedding/engine/FlutterJNI;Z)J",
          .fnPtr = reinterpret_cast<void*>(&AttachJNI),
      }
================
Text
----------------
这是一个结构体数组，可以看到nativeAttach对应的函数指针是AttachJNI，我们继续在当前文件中找到AttachJNI函数，它就是Java层nativeAttach方法的具体实现
================
Code
----------------
// Called By Java
static jlong AttachJNI(JNIEnv* env,
                       jclass clazz,
                       jobject flutterJNI,
                       jboolean is_background_view) {
  fml::jni::JavaObjectWeakGlobalRef java_object(env, flutterJNI);
  auto shell_holder = std::make_unique<AndroidShellHolder>(
      FlutterMain::Get().GetSettings(), java_object, is_background_view);
  if (shell_holder->IsValid()) {
    return reinterpret_cast<jlong>(shell_holder.release());
  } else {
    return 0;
  }
}
================
Text
----------------
这里的C++代码主要干了一件事，就是通过make_unique来创建了一个AndroidShellHolder对象，因此我们需要找到AndroidShellHolder类的构造方法
flutter/shell/platform/android/android_shell_holder.cc
================
Code
----------------
AndroidShellHolder::AndroidShellHolder(
    flutter::Settings settings,
    fml::jni::JavaObjectWeakGlobalRef java_object,
    bool is_background_view)
    : settings_(std::move(settings)), java_object_(java_object) {
  static size_t shell_count = 1;
  auto thread_label = std::to_string(shell_count++);

  FML_CHECK(pthread_key_create(&thread_destruct_key_, ThreadDestructCallback) ==
            0);

  if (is_background_view) {
    thread_host_ = {thread_label, ThreadHost::Type::UI};
  } else {
    thread_host_ = {thread_label, ThreadHost::Type::UI | ThreadHost::Type::GPU |
                                      ThreadHost::Type::IO};
  }

  // ...省略...

  // The current thread will be used as the platform thread. Ensure that the
  // message loop is initialized.
  fml::MessageLoop::EnsureInitializedForCurrentThread();
  fml::RefPtr<fml::TaskRunner> gpu_runner;
  fml::RefPtr<fml::TaskRunner> ui_runner;
  fml::RefPtr<fml::TaskRunner> io_runner;
  fml::RefPtr<fml::TaskRunner> platform_runner =
      fml::MessageLoop::GetCurrent().GetTaskRunner();
  if (is_background_view) {
    auto single_task_runner = thread_host_.ui_thread->GetTaskRunner();
    gpu_runner = single_task_runner;
    ui_runner = single_task_runner;
    io_runner = single_task_runner;
  } else {
    gpu_runner = thread_host_.gpu_thread->GetTaskRunner();
    ui_runner = thread_host_.ui_thread->GetTaskRunner();
    io_runner = thread_host_.io_thread->GetTaskRunner();
  }
  flutter::TaskRunners task_runners(thread_label,     // label
                                    platform_runner,  // platform
                                    gpu_runner,       // gpu
                                    ui_runner,        // ui
                                    io_runner         // io
  );

  shell_ =
      Shell::Create(task_runners,             // task runners
                    settings_,                // settings
                    on_create_platform_view,  // platform view create callback
                    on_create_rasterizer      // rasterizer create callback
      );

  platform_view_ = weak_platform_view;
  FML_DCHECK(platform_view_);

  is_valid_ = shell_ != nullptr;

  // ...省略...
}
================
Text
----------------
这个方法里面代码比较多，省略部分代码，我们看到最重要的几个地方，首先这里有四个线程，除了当前线程作为platform线程，还创建了三个新的线程
================
Code
----------------
gpu
ui
io
================
Text
----------------
此处当配图，来自闲鱼技术博客
四个线程分别持有一个TaskRunner对象，后续会通过这些TaskRunner来将一些操作放到对应的线程中去执行。
Platform Task Runner的线程可以理解为是主线程，它不仅仅处理与Engine交互，它还处理来自平台的消息。
UI Task Runner被用于执行Dart root isolate代码，简单说也就是Dart语言的主线程。我们所编写的Dart代码基本就是在这个线程运行。因此该线程繁忙会导致UI卡顿，如果有繁重的计算任务，如加密、解压缩等，应当在Dart中另起一个isolate来执行代码。需要注意，另启的isolate是不能与Flutter引擎交互的，表现在开发中，也就是不能在新创建的isolate中调用插件，例如在新的isolate操作SQlite数据库，如有这种需求，可以使用FlutterIsolate 库
GPU Task Runner 用于执行设备GPU的相关调用。主要是配置管理每一帧绘制所需要的GPU资源。如果该线程卡顿，直接导致程序卡顿。通常来说用平台代码和Dart代码都无法直接操作到该线程
IO Runner的主要是从图片存储（如磁盘）中读取压缩的图片格式，将图片数据进行处理，为GPU Runner的渲染做好准备。也就是处理与磁盘IO相关的事务
最后，看到以下函数的调用，此处即是创建引擎的地方
================
Code
----------------
shell_ =
      Shell::Create(task_runners,             // task runners
                    settings_,                // settings
                    on_create_platform_view,  // platform view create callback
                    on_create_rasterizer      // rasterizer create callback
      );
================
Text
----------------
大家有兴趣可以找相关源码，继续跟踪一下源码，看看引擎是如何创建的
================
Code
----------------
\flutter\shell\common\shell.cc
================
Header
----------------
运行Dart代码
================
Text
----------------
通过反编译Flutter生成的apk，我们很清楚的知道，Dart代码编译后的产物，包括相关的资源文件，实际上都是打包到安卓的assets目录下的，那么Dart代码是在哪加载执行的呢？
在FlutterActivityDelegate的onCreate方法的最后有如下代码
================
Code
----------------
String appBundlePath = FlutterMain.findAppBundlePath(activity.getApplicationContext());
 if (appBundlePath != null) {
     runBundle(appBundlePath);
 }
================
Text
----------------
这里首先获取资源文件提取后在应用所属目录下的路径，然后调用runBundle进行加载执行。runBundle方法最终调用FlutterJNI中的一个native方法
================
Code
----------------
private native void nativeRunBundleAndSnapshotFromLibrary(
      long nativePlatformViewId,
      @NonNull String[] prioritizedBundlePaths,
      @Nullable String entrypointFunctionName,
      @Nullable String pathToEntrypointFunction,
      @NonNull AssetManager manager
  );
================
Text
----------------
调用过程如下，点击大图
================
Header
----------------
总结
================
Code
----------------
FlutterActivityDelegate
onCreate
================
Text
----------------
FlutterMain.ensureInitializationComplete方法调用
FlutterApplication中onCreate调用
FlutterView创建 点击大图
FlutterNativeView创建 点击大图
================
Header
----------------
视频课程
================
Text
----------------
如需要获取完整的Flutter全栈式开发课程，请 点击跳转
================
Header
----------------
欢迎关注公众号：编程之路从0到1
================
Title
----------------
HDU6351-Beautiful Now
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/algzjh/article/details/81477772
================
Stars
----------------
0
================
Text
----------------
DFS
================
Code
----------------
#include<bits/stdc++.h>
using namespace std;
string n,minans,maxans;
int k,len;

void dfs1(string s,int pos,int step){
    if(pos>=len||step>=k) {minans=min(minans,s);return;}
    bool flag=false;
    for(int i=pos+1;i<len;i++){
        if(pos==0&&s[i]=='0') continue;
        if(s[pos]>s[i]){
            string tmp=s;
            swap(tmp[pos],tmp[i]);
            flag=true;
            dfs1(tmp,pos+1,step+1);
        }
    }
    if(!flag) dfs1(s,pos+1,step);
}

void dfs2(string s,int pos,int step){
    if(pos>=len||step>=k) {maxans=max(maxans,s);return;}
    bool flag=false;
    for(int i=pos+1;i<len;i++){
        if(s[pos]<s[i]){
            string tmp=s;
            swap(tmp[pos],tmp[i]);
            flag=true;
            dfs2(tmp,pos+1,step+1);
        }
    }
    if(!flag) dfs2(s,pos+1,step);
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    scanf("%d",&T);
    while(T--){
        cin>>n;
        minans=maxans=n;
        scanf("%d",&n);
        len=n.length();
        dfs1(n,0,0);
        dfs2(n,0,0);
        cout<<minans<<" "<<maxans<<endl;
    }
    return 0;
}
================
Title
----------------
Openfire加Smack实现IM
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/android_cai_niao/article/details/114535082
================
Stars
----------------
0
================
Header
----------------
1、服务器配置
================
Text
----------------
我买了一台华为虚拟主机，系统是Linux，并购买了域名，网站也备案了，域名为：android666.cn。
然后在这台虚拟主机上安装Openfire，安装教程可参考：https://blog.csdn.net/android_cai_niao/article/details/113861004
安装后浏览器打开http://android666.cn:9090即可打开管理后台，我的配置如下：  我把服务器名称和主机名都设置为：android666.cn，即我的网站域名。
================
Header
----------------
2、登录
================
Header
----------------
2.1 Spark注册和登录
================
Text
----------------
注册很简单，打开Spark，点击左下角的“账号”按钮进入注册界面，如下：  输入账号、密码和服务器地址，点击“创建账号”即可。
账号创建后即可进行登录，如下：  在“高级”设置中无需进行任何设置即可进行登录，一切都用默认设置即可，如下：  登录成功后，效果如下：
================
Header
----------------
2.2 Smack实现登录
================
Text
----------------
官方使用文档：https://download.igniterealtime.org/smack/docs/latest/documentation/ Smack依赖设置：https://github.com/igniterealtime/Smack/wiki/Smack-4.4-Readme-and-Upgrade-Guide
根项目的build.gradle：
================
Code
----------------
allprojects {
    repositories {
        maven {
            url 'https://oss.sonatype.org/content/repositories/snapshots'
        }
        mavenCentral()
    }
}
================
Text
----------------
Module的build.gradle：
================
Code
----------------
dependencies {
    implementation "org.igniterealtime.smack:smack-android-extensions:4.4.0"
    implementation "org.igniterealtime.smack:smack-tcp:4.4.0"
}

configurations {
    all*.exclude group: 'xpp3', module: 'xpp3'
}
================
Text
----------------
权限：
================
Code
----------------
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
================
Text
----------------
SDK初始化，可放到Appliation中进行：
================
Code
----------------
AndroidSmackInitializer.initialize(this)
================
Text
----------------
配置好这些之后，就可以开始写代码了，官方教程中演示了一个登录的示例，如下：
================
Code
----------------
private fun login() {
    thread {
        try {
            val connection = XMPPTCPConnection("test001", "123456", "android666.cn")
            connection.connect().login()
            toast("登录成功")
        } catch (e: Exception) {
            Log.e(tag, "登录失败", e)
            toast("登录失败")
        }
    }
}
fun toast(text: CharSequence) {
    if (Looper.myLooper() == Looper.getMainLooper()) {
        Toast.makeText(this, text, Toast.LENGTH_SHORT).show()
    } else {
        runOnUiThread {
            Toast.makeText(this, text, Toast.LENGTH_SHORT).show()
        }
    }
}
================
Text
----------------
登录代码是很简单，但是登录时失败的，报错如下：
================
Code
----------------
2021-03-08 15:50:10.499 13630-13727/cn.android666.imdemo E/MainActivity: 登录失败
    org.jivesoftware.smack.SmackException$SmackWrappedException: javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.
        at org.jivesoftware.smack.AbstractXMPPConnection.setCurrentConnectionExceptionAndNotify(AbstractXMPPConnection.java:690)
        at org.jivesoftware.smack.AbstractXMPPConnection.notifyConnectionError(AbstractXMPPConnection.java:994)
        at org.jivesoftware.smack.tcp.XMPPTCPConnection.access$4100(XMPPTCPConnection.java:130)
        at org.jivesoftware.smack.tcp.XMPPTCPConnection$PacketReader.parsePackets(XMPPTCPConnection.java:1152)
        at org.jivesoftware.smack.tcp.XMPPTCPConnection$PacketReader.access$700(XMPPTCPConnection.java:913)
        at org.jivesoftware.smack.tcp.XMPPTCPConnection$PacketReader$1.run(XMPPTCPConnection.java:936)
        at java.lang.Thread.run(Thread.java:929)
================
Text
----------------
这里我并没有把异常贴完整，但也足够了解原因了，关键点：CertPathValidatorException: Trust anchor for certification path not found. 这一看就知道是证书的问题，我们并没有为Openfire配置证书，但是默认登录时它会使用证书配置进行登录，所以报错了。所以解决方案就是在登录时，让他不要使用证书，如下：
================
Code
----------------
private fun login() {
    thread {
        try {
            val config = XMPPTCPConnectionConfiguration
                .builder()
                .setUsernameAndPassword("test001", "123456")
                .setXmppDomain(JidCreate.domainBareFrom("android666.cn"))
                .setSecurityMode(ConnectionConfiguration.SecurityMode.disabled) // 禁用安全模式
                .build()
            val connection = XMPPTCPConnection(config)
            connection.connect().login()
            toast("登录成功")
        } catch (e: Exception) {
            Log.e(tag, "登录失败", e)
            toast("登录失败")
        }
}
================
Text
----------------
再次登录，就可以登录成功了！
================
Title
----------------
【Excel 教程系列第 11 篇】Excel 如何快速下拉填充序列至 10000 行
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/103484297
================
Stars
----------------
44
================
Text
----------------
这是【Excel 教程系列第 11 篇】，如果觉得有用的话，欢迎关注专栏。
================
Header
----------------
文章目录
================
Header
----------------
一：问题描述
================
Text
----------------
在 Excel 中，下拉输入的数据时，如果序列比较少，下拉然后选择填充序列就行了。但如果让序列递增到 10000，再手动下拉就显得既耗时效率又低了，有没有什么方法可以直接下拉到指定序列呢 ？
================
Header
----------------
二：解决方案
================
Text
----------------
因截取屏幕的限制问题，这里我只指定下拉到第 20 行。
1：推荐
先在单元格输入 1 ，然后切换到【开始】选项卡，再点击【填充】，选择【序列】，再选择序列产生在【列】，【终止值】填 20 ，最后按确定按钮即可。动态效果演示图如下  说明： 1：如果你希望横向递增序列，则选择序列产生在行。 2：如果你希望递增的差值为 n ，则将【步长值】设置为 n 即可。 3：如果你希望递增到 10000 ，则将【终止值】设置为 10000 即可。
2：使用函数
第一步
在 A1 单元格输入 1 ，然后选中 A2 单元格，在"名称框"中填写 A2:A20 ，然后按回车键，此时将选中 A2 到 A20 ，动态效果演示图如下  如果你想指定下拉到第 10000 行，则只需将 A20 写成 A10000 即可。
第二步 下面提供两种快速下拉到指定序列的方法，效果都是一样的。
方法一： 此时仍是选中 A2 单元格状态，然后在"编辑栏"中填写 =A1+1，然后按下 Ctrl + 回车 组合键，就可以得出 1 ~ 20 的递增数据了，动态效果演示图如下  注意是按的 Ctrl + 回车 ，如果你按的是回车键，则只会出来一个数值 2。
方法二： 仍是选中 A2 单元格状态，在"编辑栏"中填写函数 =row()，然后按下 Ctrl + 回车 组合键，就可以得出 1 ~ 20 的递增数据了，动态效果演示图如下  你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【综合类型第 16 篇】W3School 离线手册最新版下载
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/104705746
================
Stars
----------------
79
================
Text
----------------
这是【综合类型第 16 篇】，如果觉得有用的话，欢迎关注专栏。
话不多说，今天分享一个 W3School 离线手册的最新版，如下图所示
图一（Windows 截图）  图二（Mac 截图）  下载解压前后图示如下
注： chm 是微软新一代的帮助文件格式，利用 HTML 作源文，把帮助内容以类似数据库的形式编译储存。
所以 Windows 系统可以直接打开 .chm 类型的文件，但是在 Mac 系统上是无法直接打开查看的。
在 Mac 上面如何打开 .chm 格式的文件呢？只需要在 AppStore 上搜索 chm 关键字即可。
如下图所示  点击此处获取链接  提取码：wib7
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【Flutter 问题系列第 56 篇】执行 flutter doctor 命令后提示 Unable to find bundled Java version 的解决方案
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/122461385
================
Stars
----------------
7
================
Text
----------------
这是【Flutter 问题系列第 56 篇】，如果觉得有用的话，欢迎关注专栏。
当前开发环境 Flutter 版本：2.2.3，Dart 版本：2.13.4，操作系统：macOS BigSur 11.4 M1，Android Studio 版本：Arctic Fox 2020.3.1 Pathc 4。
================
Header
----------------
文章目录
================
Header
----------------
一：问题描述
================
Text
----------------
在终端执行 flutter doctor 命令后，如下图所示  警告信息是 Unable to find bundled Java version ，翻译后的意思是 无法找到绑定的 Java 版本 。
================
Header
----------------
二：解决方案
================
Text
----------------
也是找了好几个解决方案，尝试后都不行，最终还是在 flutter 库的 Issues 中找到了解决方案，如下图所示  我根据上述描述整理了一下，如果你能直接看出来就可以不用往下看了。
第一步
找到你本地的 Flutter SDK，依次点开 flutter / packages / flutter_tools / lib / src / android / android_studio.dart ，打开 android_studio.dart 文件后，滑动到最下面，删除掉下图所示代码处的字符串 jdk 。  删除后的效果图如下  第二步
依次选择 访达 / 应用程序 / Android Studio / ，右击 Android Studio 应用程序图标后选择 显示包内容，
然后再依次点开 Contents / jre，你 jre 文件夹下目前应该是只有 Contents 文件夹，复制该 Contents 文件夹后，
手动在 jre 文件夹下新建一个 jdk 文件夹，然后把刚才复制的 Contents 文件夹粘贴到 jdk 文件夹下，如下图所示  这个时候准备工作就完成了，然后再在终端执行 flutter doctor 命令，效果图如下  警告信息已消失，Perfect 。
至此，关于执行 flutter doctor 命令后提示 Unable to find bundled Java version 问题的解决方案便介绍到这里。
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【HTML 教程系列第 19 篇】HTML 表格中的行合并与列合并
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/102828018
================
Stars
----------------
75
================
Text
----------------
这是【HTML 教程系列第 19 篇】，如果觉得有用的话，欢迎关注专栏。
在使用 Excel 的时候，会经常的用到合并单元格，而在 HTML 的表格中，有时我们也需要将横向的多个单元格或者纵向的多个单元格合并成一个单元格，如何实现呢？
================
Header
----------------
文章目录
================
Header
----------------
一：合并单元格步骤
================
Header
----------------
二：行合并 rowspan
================
Text
----------------
作用 在 HTML 中，可以使用属性 rowspan 来合并行，即合并纵向的多个相邻单元格。
举例说明 代码如下所示
================
Code
----------------
<table align="center" cellspacing="15" cellpadding="15">
	<caption>统计表</caption>
	<tr>
		<td>123</td>
		<td>123</td>
		<td>123</td>
	</tr>
	<tr>
		<td>abc</td>
		<td>abc</td>
		<td>abc</td>
	</tr>
	<tr>
		<td>一二三</td>
		<td>一二三</td>
		<td>一二三</td>
	</tr>
</table>
================
Text
----------------
浏览器运行效果如下所示  大多数软件中，行指的都是横向的，列指的都是纵向的。
需求：合并第二行第一列的 “abc” 和第三行第一列的 “一二三”  我们按照合并单元格的步骤一步一步来。
第一步：首先确定该需求属于跨行合并单元格，
第二步：跨行合并单元格按照先上后下的规则，什么是先上后下的规则呢？简单来说，就是哪个单元格在上面，就把属性 rowspan 写到对应的单元格标签 td 中。所以我们需要先找到第二行第一列的单元格 td，局部代码如下所示
================
Code
----------------
<tr>
		<td>123</td>
		<td>123</td>
		<td>123</td>
	</tr>
	<tr>
		<td rowspan="2">abc</td>
		<td>abc</td>
		<td>abc</td>
	</tr>
	<tr>
		<td>一二三</td>
		<td>一二三</td>
		<td>一二三</td>
	</tr>
================
Text
----------------
rowspan 的属性值填写的是数字，你要合并的单元格有几个，就写几。
到这里如果我们直接运行代码，会出现什么情况呢 ？浏览器运行效果如下所示  你会发现整个表格全乱了。
为什么会出现这种情况呢 ？ 答：我们在合并单元格的时候，如果被合并的单元格有内容，虽然不会影响到合并，但因为被合并的单元格内容没做任何处理，所以单元格会自动后移。
如何解决这种情况呢？ 很简单，直接删除多余的单元格即可。 这里有个小公式： 删除的个数 = 合并的个数 - 1，这也是我们的第三步。
因为第三行第一列的单元格已经被合并了，所以我们需要将它删除，更改后的代码如下所示
================
Code
----------------
<tr>
		<td>123</td>
		<td>123</td>
		<td>123</td>
	</tr>
	<tr>
		<td rowspan="2">abc</td>
		<td>abc</td>
		<td>abc</td>
	</tr>
	<tr>
		<td>一二三</td>
		<td>一二三</td>
	</tr>
================
Text
----------------
浏览器运行效果如下所示  ok，到这里我们已经实现了跨行合并。
================
Header
----------------
三：列合并 colspan
================
Text
----------------
作用 在 HTML 中，可以使用属性 colspan 来合并列，即合并横向的多个相邻单元格。 其中 colspan 是 column span（跨列）的英文缩写。
举例说明 代码如下所示
================
Code
----------------
<table align="center" cellspacing="15" cellpadding="15">
	<caption>统计表</caption>
	<tr>
		<td>123</td>
		<td>123</td>
		<td>123</td>
	</tr>
	<tr>
		<td>abc</td>
		<td>abc</td>
		<td>abc</td>
	</tr>
	<tr>
		<td>一二三</td>
		<td>一二三</td>
		<td>一二三</td>
	</tr>
</table>
================
Text
----------------
需求：合并第二行第二列的 “abc” 和同行第三列的 “abc”  第一步：首先确定该需求属于跨列合并单元格，
第二步：跨列合并单元格按照先左后右的规则，什么是先左后右的规则呢？简单来说，就是哪个单元格在左边，就把属性 colspan 写到对应的单元格标签 td 中。所以我们需要先找到第二行第二列的单元格 td。
第三步：删除第二行第三列的单元格，局部代码如下所示
================
Code
----------------
<tr>
		<td>123</td>
		<td>123</td>
		<td>123</td>
	</tr>
	<tr>
		<td>abc</td>
		<td colspan="2">abc</td>
	</tr>
	<tr>
		<td>一二三</td>
		<td>一二三</td>
		<td>一二三</td>
	</tr>
================
Text
----------------
浏览器运行效果如下所示  到这里我们已经实现了跨列合并。
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【综合类型第 38 篇】如何查看、安装最新版本、旧版本的 Cocoapods
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/127710221
================
Stars
----------------
0
================
Text
----------------
这是【综合类型第 38 篇】，如果觉得有用的话，欢迎关注专栏。
我们知道 Cocoapods 是帮助我们管理第三方依赖库的工具，可以用来解决库与库之间的依赖关系。
比如当前我本地的版本是 1.11.2，如下图所示
一：如何查看当前 Cocoapods 版本有哪些 ？
✈ ✈ ✈ ✈ ✈ 直接点击此处 ✈ ✈ ✈ ✈ ✈
跳转后的图示如下
可以看到当前最新版本是 1.11.3，你可以根据需要点击对应版本号跳转到新页面，剩下的就自己操作了。
二：如何更新指定版本的 Cocoapods
以更新到 1.11.3 版本为例，执行命令
================
Code
----------------
sudo gem install -n /usr/local/bin cocoapods -v 1.11.3
================
Text
----------------
三：如何安装最新版本的 Cocoapods
执行命令
================
Code
----------------
$ sudo gem install -n /usr/local/bin cocoapods --pre
================
Text
----------------
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
SDL编程入门（18）按键状态
================
License
----------------
None
================
Stars
----------------
1
================
Header
----------------
按键状态
================
Text
----------------
正如我们在鼠标输入教程中看到的那样，除了使用事件之外，还有其他方法可以获得输入设备（鼠标、键盘等）的状态。在本教程中，我们将使用按键状态而不是事件来重新制作键盘输入教程。
================
Code
----------------
//Main loop flag
bool quit = false;

//Event handler
SDL_Event e;

//Current rendered texture
LTexture* currentTexture = NULL;
================
Text
----------------
在进入主循环之前，我们声明一个纹理指针来跟踪我们要渲染到屏幕上的纹理。
================
Code
----------------
//While application is running
while( !quit )
{
    //Handle events on queue
    while( SDL_PollEvent( &e ) != 0 )
    {
        //User requests quit
        if( e.type == SDL_QUIT )
        {
            quit = true;
        }
    }
    //根据当前的按键状态设置纹理
    const Uint8* currentKeyStates = SDL_GetKeyboardState( NULL );
    if( currentKeyStates[ SDL_SCANCODE_UP ] )
    {
        currentTexture = &gUpTexture;
    }
    else if( currentKeyStates[ SDL_SCANCODE_DOWN ] )
    {
        currentTexture = &gDownTexture;
    }
    else if( currentKeyStates[ SDL_SCANCODE_LEFT ] )
    {
        currentTexture = &gLeftTexture;
    }
    else if( currentKeyStates[ SDL_SCANCODE_RIGHT ] )
    {
        currentTexture = &gRightTexture;
    }
    else
    {
        currentTexture = &gPressTexture;
    }
    //Clear screen
    SDL_SetRenderDrawColor( gRenderer, 0xFF, 0xFF, 0xFF, 0xFF );
    SDL_RenderClear( gRenderer );

    //Render current texture
    currentTexture->render( 0, 0 );

    //Update screen
    SDL_RenderPresent( gRenderer );
}
================
Text
----------------
正如你所看到的，我们没有在事件循环中检查按键事件。我们所有的键盘输入都将通过键状态来处理。
关于SDL如何处理键状态，有一点很重要，那就是你仍然需要一个事件循环运行。SDL的内部键状态每次调用SDL_PollEvent时都会更新，所以在检查键状态之前要确保你已经轮询了队列上的所有事件。
这里我们设置了要渲染的纹理。首先，我们使用 SDL_GetKeyboardState获得一个指向按键状态数组的指针。所有键的状态都是由 SDL_Scancode 排序的。扫描码就像SDL_Keycode的值一样，只是扫描码被设计成可以和国际键盘一起使用。根据键盘布局的不同，不同的字母可能在不同的位置。扫描码是根据默认的物理按键位置，而不是它们在特定键盘上的位置。
您所要做的就是检查某个键是否被关闭，检查它在键状态数组中的状态。正如你在上面的代码中所看到的那样，如果键是按下的，我们将当前的纹理设置为相应的纹理。如果键都没有按下，我们就设置默认的纹理。
最后在这里，我们将当前纹理渲染到屏幕上。
在 这里下载本教程的媒体和源代码。
原文链接
关注我的公众号：编程之路从0到1
================
Title
----------------
【Flutter 问题系列第 57 篇】Context: Found this candidate, but the arguments don‘t match. const MaterialApp
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/122484216
================
Stars
----------------
1
================
Text
----------------
这是【Flutter 问题系列第 57 篇】，如果觉得有用的话，欢迎关注专栏。
当前开发环境 Flutter 版本：2.2.3，Dart 版本：2.13.4，操作系统：macOS BigSur 11.4 M1，Android Studio 版本：Arctic Fox 2020.3.1 Pathc 4。
今天碰到的这个问题算是打破了我以往的认知，特此记录下。
================
Header
----------------
文章目录
================
Header
----------------
一：问题描述
================
Text
----------------
新建了一个 Flutter 项目 A，然后复制了本地另外一个项目 B 的 pubspec.yaml 文件到 A 项目，以为 B 项目都能正常的运行，A 项目自然而然的没问题，然后就报出了如下问题  关键词一是 flutter/.pub-cache/hosted/pub.flutter-io.cn/get-4.6.1 插件中的 get_cupertino_app.dart 文件报错，
报错原因是No named parameter with the name 'useInheritedMediaQuery，翻译后的意思是 没有名称为useInheritedMediaQuery 的命名参数。
关键词二是 flutter/packages/flutter/lib/src/cupertino/app.dart 文件报错，
报错原因是 Context: Found this candidate, but the arguments don't match. const MaterialApp，翻译后的意思是 上下文：找到了候选对象 const MaterialApp，但参数不匹配。
还有另外一个错误如下图所示  关键代码是 flutter/packages/flutter_tools/gradle/flutter.gradle' line: 1035，报错位置在 Flutter SDK，刚开始以该错误为关键字搜索解决方案了，然后浪费了好几个小时，这里提前提个醒。
之所以把错误原因写的这么详细，是因为如果你此时的问题和我的报错内容不一样，那就不用向下看了，我在搜索解决方案时看到了很多以为能解决的，也一个个尝试了，但没一个能解决的，着实耽误了很多时间。
如果你的报错信息和我的一样，那么请退后，因为我要开始…了。
================
Header
----------------
二：问题分析
================
Text
----------------
因为实在找不来解决方案，想着去 get 库的 Issues 看看有没有人遇到和我一样的问题，果然，被我找到了 Issues。  因为我本地的 Flutter 版本是 2.2.3，方案一应该是可行的，但代价有点高，所以尝试了下面的解决方案。
================
Header
----------------
三：方案一(不推荐)
================
Text
----------------
根据错误原因一的提示，跳转到相应的代码处，如下图所示  只修改属于 get 插件的错误的代码，报 Flutter SDK 错误的先不用管，我把属于 get 插件错误的修改完后重新运行，此时没有问题，可以正常运行。
虽然这个方案可以解决，但毕竟修改了 get 插件的源码，所以并不是最理想的解决方案，接着就是下面推荐的方案二了，也是从根本上解决了这个问题。
================
Header
----------------
四：方案二(推荐)
================
Text
----------------
通过错误原因二，可以知道当前报错位置是插件 get-4.6.1 ，但我本地的 pubspec.yaml 文件指定的是 get 插件的 4.3.8 版本啊，如下图所示  查看 get 最新的版本，截至到 2022年01月13日 ，也是 get-4.6.1  版本，这肯定不是巧合。
关键是这个脱字符号 ^，我以前以为这是插件的规定写法，其实不是，它的含义是 自动使用当前插件的最新版本。
因为 B 项目是几个月前的，当时 get 插件最新版本是 4.3.8，所以 B 项目没问题。
我出错的是 get 插件，用插件的 GetMaterialApp 组件代替了 Flutter 原生的 MaterialApp，Flutter 版本低，但 get 版本太高了造成了这个问题。
所以，我们把脱字符号 ^ 去掉，指定项目中用的就是 get 插件 4.3.8 版本，如下图所示  如果你修改后执行 flutter pub get 命令后，发现插件没有更新，这是因为插件缓存的原因，在访达中找到 get-4.6.1 文件夹，手动删除然后重新获取依赖即可。
其实从头到尾就是去掉一个脱字符号 ^ 的事情，但这是解决了才这样说，这个解决问题的过程特此记录下，希望可以帮到你。
至此，关于在 Flutter 中运行项目提示 Context: Found this candidate, but the arguments don’t match. const MaterialApp 的解决方案便介绍到这里。
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【Git 教程系列第 26 篇】Mac 升级系统到 Ventura 后，Git 公钥报 Permission denied 错误问题的解决方案
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/128195284
================
Stars
----------------
0
================
Text
----------------
这是【Git 教程系列第 26 篇】，如果觉得有用的话，欢迎关注专栏。
注： 如果你是因为升级系统到 Ventura 后遇到的这个问题，可以直接看第三步的解决方案，前两步是我自己的写作习惯，只是记录一下这个过程，当然你也能从中读到更多的信息。
================
Header
----------------
文章目录
================
Header
----------------
一：问题描述
================
Text
----------------
因为项目的 Xcode 版本要更新到 14，我自己的 Mac 电脑系统版本是 Catalina 10.15.7 的，不兼容 Xcode 14 版本，所以只能升级 Mac 系统了，然后就升到了 Ventura 13.0.1。
升级后用 git pull 拉取代码的时候，提示让我输入密码，我以为是升级系统后的安全验证，就输入了密码。
我能确定输入的密码是正确的，但却提示
Permission denied, please try again(权限被拒绝，请重试).
然后又不信自的再次输入密码，第二次提示的和第一次一样，第三次系统认为的“输入错误”后，提示
Permission denied (publickey,password).权限被拒绝，还让我确认项目是否存在
如下图所示
情况也就是这么个情况，1 个小时前在公司项目拉取还是好好的呢，这不是开玩笑吗？盘它。
================
Header
----------------
二：解决过程
================
Code
----------------
vi /etc/ssh/sshd_config
================
Text
----------------
这也不行，那也不行，男人不能说自己不行啊。
然后就想着，难道是升级后，SSH 更改了验证方式？然后就找到了一篇文章，点击查看原文
文章里说的很清楚，为什么会引发这个问题，以及如何解决的，一种是兼容以前的 ssh-rsa 算法，另外一种是用 Ed25519 算法代替以前的 ssh-rsa 算法，我用的是后者，所以做下记录。
================
Header
----------------
三：解决方案
================
Text
----------------
既然是用 Ed25519 算法代替以前的 ssh-rsa 算法，所以就要删除掉远端的 SSH Key，重新用 Ed25519 算法配置一次公钥到远端就行了。
在终端执行命令 ssh-keygen -t ed25519 ，然后连续按 3 次 Enter 键，如下图所示
然后在本地的 .ssh 文件夹下会生成两个文件，其中 id_ed25519 文件中的内容就是我们需要添加到远端 SSH Key 的，
如下图所示
至于如何配置 SSH Key，针对不同的系统我也写过相关流程，链接如下
博客中写的很详细，不懂的一步一步根据提示来就行了。
至此，Mac 升级系统到 Ventura 后，Git 公钥报 Permission denied 错误问题的解决方案就说到这里了。
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【Windows 问题系列第 3 篇】Win10 系统如何打开/关闭护眼模式
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/90901138
================
Stars
----------------
44
================
Text
----------------
这是【Windows 问题系列第 3 篇】，如果觉得有用的话，欢迎关注专栏。
win10 提供了一种保护视力的模式(护眼模式)，一般设置窗口颜色为豆沙绿，可以降低长时间工作时电脑对眼睛造成的疲劳感。
该模式下，你电脑上的浏览器，Excel表格，Word表格，txt 文档等窗口的背景色都会变成豆沙绿，如下图
保护视力是好事，可并不是每一个人都喜欢这种背景色。而且有时 Windows 会自动开启护眼模式，博主是非常不喜欢这种背景色的，接下来我说下如何开启，关闭 Win10 默认窗口背景色为护眼色的方法。
首先，请关闭任务栏里的所有窗口，方便最后注销，重启。
第一步：
按 Windows+R 组合键，打开“运行”对话框，输入 regedit ，点击“确定”，打开“注册表编辑器”；  第二步：
修改第一个注册表 HKEY_CURRENT_USER→Control Panel→Colors 下 Windows 的键值，
第三步：
修改第二个注册表 HKEY_LOCAL_MACHINE→SOFTWARE→Microsoft→Windows→CurrentVersion→Themes→DefaultColors→Standard 下 Windows 的键值
注意：修改注册表没有保存和确定键。
修改后先注销用户，然后在锁屏界面直接点重启即可。
一定要先注销用户！一定要先注销用户！一定要先注销用户！
最后，看效果  你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【Mac 教程系列第 10 篇】如何在 Mac 上破解带有密码的 ZIP 压缩文件
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/117826817
================
Stars
----------------
50
================
Text
----------------
这是【Mac 教程系列第 10 篇】，如果觉得有用的话，欢迎关注专栏。
我们知道如果是一般的压缩文件，可以用系统自带的或者很好用的压缩工具 Keka 来解压，但如果要解压的压缩文件设置了密码，这个时候怎么做呢？
================
Header
----------------
文章目录
================
Header
----------------
一：下载 Homebrew
================
Text
----------------
你可以直接去 Homebrew 官网 下载，当然如果下载慢的话，我之前写了一篇关于如何下载 Homebrew 的教程，可以 点击跳转 。
================
Header
----------------
二：安装 fcrackzip
================
Text
----------------
我们要用的是一个名为 fcrackzip 的压缩工具，打开终端，在命令行中输入
================
Code
----------------
brew install fcrackzip
================
Text
----------------
然后按下回车后即可安装。
================
Header
----------------
三：关于 fcrackzip 的参数
================
Text
----------------
在终端输入 fcrackzip -h 命令可以查看关于压缩时的详细参数，如下图所示  参数后面都有详细的说明，不再说明，下面直接说下如何使用，请看第四步。
================
Header
----------------
四：如何使用 fcrackzip 解压带密码的压缩文件
================
Text
----------------
直接在终端输入一行代码就行
================
Code
----------------
fcrackzip  -b -c 'aA1' -l 1-10 -u
================
Text
----------------
然后在后面跟上你要解压文件的绝对路径（直接把你的文件拖动到终端即可），如下图所示  建议 建议把你的文件名改为纯英文字母，比如 aaa 等，因为有的粉丝的文件名包括但不限于 反斜杠 \ 、空 格、特殊符号如 #，%，*，[，<，《，+，& 等，不要卡在文件名的问题上。
最后按下 Enter 键，然后等待 fcrackzip 帮你暴力破解密码就行，破解时间由密码的复杂度和硬件的性能相关，我这个大概用了 30 多秒就给破解掉了，然后瞬间省下了 20 多元宝，哈哈。
不过不敢保证这个方法一定会有用，就我自己而言，用起来还是不错的。
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
【软件推荐系列第 3 篇】如何下载、设置时钟屏保
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/128275360
================
Stars
----------------
0
================
Text
----------------
这是【软件推荐系列第 3 篇】，如果觉得有用的话，欢迎关注专栏。
为避免 CSDN 审核时把这篇文章以广告类型划分，下面的字母 A 代表 fliqlo。
后台不少人问我怎么给电脑设置时钟屏保的，效果如下图所示
其实很简单，下载一个叫 A 的软件就行了，同时支持 Mac 和 Windows 系统，也可以给 iPad 和手机设置时钟屏保。
点击链接进入 A 后，选择你要设置的设备类型，比如这里我选择为电脑设置时钟屏幕，就点击当前页面的电脑图标，然后根据你选择的设备类型会跳转到下一个不同的页面，如下图所示
可以看到软件是免费使用的，下载后根据提示正常安装就行了，快去试试吧！
你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
深入浅出Google Clould Platform （1）----GCP 考证
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/102334432
================
Stars
----------------
40
================
Text
----------------
笔者发现，在国内不但关于Google云的资料很少，考点很少，而且博客也很少，也许是因为用的比较少，也许是因为写Google云方面的博客的阅读量不会太高，所以很多的博客写主不会投入很多精力去写。其实在国外，Google云还是用的很广泛的，是三大主流的云供应商： AWS， Google Cloud Platform， AZure。本系列课程主要集中在笔者学习和考证过程中的学习心得和积累。希望能抛砖引玉，对大家有所帮助。
本章节，主要给大家介绍如何考证。 目前谷歌云提供下面的认证考试: 分为三大类：
工欲善其事必先利其器，相对于亚马逊的AWS，GCP的中文资料很少，那么应该如何学习GCP呢？ 个人建议如下：
如果公司或者个人有条件的话，首先注册一个Google Cloud Platform的账号 如果是第一次可以免费试用一年
推荐书籍： 《Google Cloud Platform Cookbook》 适合入门级的同学阅读。
有基础后，可以阅读《Google Cloud In Action》目前没有中文版，只有英文版。 特别适合考架构师和云开发工程师的同学阅读。  在考试前可以把下面的书给看了。其是对考架构师的各种技术知识进行了总结。  3. 如果条件允许的话，可以到Cousera网站上面购买GCP的课程，可以系统的学习，同时Cousera在每个章节完成后，还提供临时的GCP账号，供学员练习。如果感觉Coursera有点贵，可以到下面的网站买一个学习包。
getGCPCertification网站
如果上面的书和视频都看完的话，就可以考虑，根据书上的例子，用Cloud的SDK，也就是gcloud的命令，自动化创建VM，搭建负载均衡，创建Instance Group， 创建Cloud SQL 数据库，值得注意的是，有的GCP的服务是非常昂贵的，比如Cloud Spanner， Cloud Bigtable， 只要一创建实例，一般都是至少3个节点；此外存储的数据的费用另算，而且跨区域传输数据还要额外收费；所以如果是自己的免费账号，实验完成后一定要记得清除，否则到了月末就要吃土了。
如果GCP的SDK都学会了，就可以尝试使用TerraForm去实现 “Write, Plan, and create Infrastructure as Code”, 基础架构即代码。其几乎支持所有的云平台，有兴趣可以去 https://www.terraform.io 学习。
国内如何报名？ 国内可以到下面这个站点报名，需要注意的是，需要信用卡支付。 https://www.webassessor.com/
最后，借花献佛，https://medium.com/google-cloud/网站上面的一些总结图，笔者感觉很给力。
参考文献： https://github.com/ddneves/awesome-gcp-certifications https://www.getgcpcertified.com/courses/free-trial-professional-cloud-architect/lectures/11207430
================
Title
----------------
[7]深度学习和Keras---- 快速入门心得
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/74936747
================
Stars
----------------
2
================
Text
----------------
上个礼拜终于给公司技术达人们分享完了深度学习和Keras，这其中也走过了不少的弯路。比如笔者一上来就开始看Keras，看TenseFlow，看Theano,一下子买了4五本类似的书，结果看了半天，感觉索然无味，必须要强迫自己看下去，但是里面的微积分，线性代数，概率统计，最优化方法，笔者自从研究生毕业以后，已经有7,8年没有看过这些公式了，都忘的差不多了。那如何是好呢？ 下面笔者学习的心路历程，不应适合所有的人，只是分享了，希望能抛砖引玉，能够让一小部分学习深度学习的初学者，哪怕少走一丁点弯路，也就心满意足了。
@ 因为深度学习这门课，需要有一定的数学功底，但是一上来就让大家学习积分，线性代数，概率统计，最优化方法有点让人望而生畏。所以笔者建议，大家可以先到网上找一些简单的视频来看看，比如莫烦的Keras,每个视频讲的很短。而且还有视频和代码，大家可以过一遍，并安装视频把代码敲一遍，哪怕不理解。如果英语好的，可以看斯坦福的人工智能或者深度学习的视频。
@ 在看视频的时候，必须找到一个深度学习的开发框架自己倒腾倒腾，笔者感觉Keras是一个不错的选择，为什么呢？简单。 而且运行Keras的时候，最好在非window机器上安装，比如Ubuntu或者Mac等。否则一旦安装不顺利，则会让人感到很沮丧。
@ 这个时候，可以学学Python。不一定要学的很精通，但是需要知道其中的一些基本用法和概念，比如，数组，元组的处理，方法的调用，类的实例化，而且特别注意Python的语法是非常强大和灵活的，其可以一次性返回多个不同的值。
@学些了Python之后，把高等代数中的微积分，线性代数或者概率论中的一些基本概率了解一下。
@ 如果英文好的话，看一下下面这本入门的书籍，如果英文不好，找它的中文翻译版本。
http://neuralnetworksanddeeplearning.com/
@看了之后，在看台湾大学李宏毅老师的PPT，PPT做的非常的好。其中反向传播这个章节还有视频讲解。
其PPT的头一页如下。
@等把上面的PPT看完之后，在来看莫烦已经Keras提供的例子并尝试运行。
等把上面所有的步骤都走了一遍之后，基本上深度学习就算入门了。
================
Title
----------------
行为驱动开发（BDD）你准备好了吗？
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/77543494
================
Stars
----------------
5
================
Text
----------------
最近在研究行为驱动开发（Behavior Drive Development ）, 那什么是BDD（行为驱动开发）？为什么使用行为驱动开发？用什么框架来做行为驱动开发？行为驱动开发的核心原理是？有行为驱动开发的例子吗？ 敬请关注笔者的这片文章。
根据BDD in action一书的介绍，  Behavior-Driven Development (BDD) is a set of software engineering practices  designed to help teams build and deliver more valuable, higher quality software faster.  It draws on Agile and lean practices including, in particular, Test-Driven Development  (TDD) and Domain-Driven Design (DDD). But most importantly, BDD provides a common language based on simple, structured sentences expressed in English (or in the native language of the stakeholders) that facilitate communication between project team members and business stakeholders.
翻译成中文的大概意思就是，行为驱动开发是一个软件工程的系列实践，能够帮助团队快速构建和交付更多价值和质量的软件产品。其和敏捷已经精益的开发实践，是一脉相承的，特别是测试驱动开发，已经领域驱动开发。但是最重要的是BDD提供了一种通用的，简单的，结构化的描述语言，这种语言既可以是英语也可以是其他本地的语言，通过他能够很方便让项目成员和业务干系人非常顺畅的沟通需求，及时这些干系人不懂的任何编程语言。下面就是一个例子。
是不是很好读懂，上面其实就叫Feature（特性文件），其遵循的Gherkin标准，其有下面的关键字，很好理解，  • Feature  • Background  • Scenario  • Given  • When  • Then  • And  • But  • *  • Scenario Outline  • Examples  这种特性文件，客户，项目经理，BA，QA都能看懂，因为其就是一个故事点或者需求点，而且通过特定的工具，比如cucumber的工具，能够把其自动转换成为代码。开发人员根据自动生成的代码，断言一些预期的行为，并根据这些行为，完成相应的代码实现，在代码实现的基础上，进行重构； 这样就为一个项目中的各个人员了解项目的需求，实现提供了一个很好的交互桥梁。下面是其一个交互的过程。
如果是传统的方式，其交互方式，应该是，
通过对比，大家是不是发现BDD的这种方式，把用户或者客户真正的通过Feature文件联系在一起了，其沟通是顺畅的，QA，BA，开发，测试，客户，用户可以通过这一媒介，进行高效无障碍的沟通，而不是像传统的方式，通过BA进行二次转达，从而丢失了很多重要的需求。  由此可见，其BDD的好处如下：
下面看一个简单的例子，
从上图可以看出，当一个需求过来的时候，先通过项目干系人都能理解的Feature文件，描述项目的User Story， 有的里面还有详细生动的数据范例（example），从而能够让所有的人更加容易理解其需求， 比如，
通过上面的数据范例（example）的表格是不是更加容易的理解当前case的意图了。当Feature和Example文件都完成后，借助于第三方的开源框架实现，比如Cucumber，jBehave，SpecFlow等把Feature和Example装换成代码，然后通过第层次的单元测试框架，比如JUnit，NUnit，Spock，RSpec，结合测试驱动开发，从而把业务代码的逻辑实现。真是一举多得。
笔者就以Cucumber和JUnit为例，举一个BDD的例子吧。大家对JUnit比较熟悉，但是对Cucumber可能会相对陌生一点，笔者就花一点笔墨，简单介绍了一下Cucumber。Cucumer是一个实现了BDD的一个框架，其支持下面的语言和框架集成，
是不是感觉很强大啊！！！！ 下面进入实战，
1. Maven库的依赖
================
Code
----------------
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>uk.co.claysnow</groupId>
  <version>1.0</version>
  <packaging>jar</packaging>
  <name>Cucumber-JVM Book ATM Example</name>
  <artifactId>atm-example</artifactId>

    <properties>
        <cucumber.version>1.2.0</cucumber.version>
        <junit.version>4.11</junit.version>
        <picocontainer.version>2.14.2</picocontainer.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>info.cukes</groupId>
            <artifactId>cucumber-junit</artifactId>
            <version>${cucumber.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>info.cukes</groupId>
            <artifactId>cucumber-picocontainer</artifactId>
            <version>${cucumber.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.picocontainer</groupId>
            <artifactId>picocontainer</artifactId>
            <version>${picocontainer.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

  <build>
      <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.12.2</version>
            <configuration>
                <argLine>-Duser.language=en</argLine>
                <argLine>-Xmx1024m</argLine>
                <argLine>-XX:MaxPermSize=256m</argLine>
                <argLine>-Dfile.encoding=UTF-8</argLine>
                <useFile>false</useFile>
              </configuration>
          </plugin>

      </plugins>
  </build>

</project>
================
Text
----------------
2. 安装Cucumber Eclipse插件
为了支持Feature的Gherkin语法，我们需要在Eclipse安装下面的插件：  https://cucumber.io/cucumber-eclipse/update-site  具体安装方法，请到百度或者google搜索。下面看一个具体的例子：
3. Feature文件
================
Code
----------------
Feature: Cash Withdrawal
  Scenario: Successful withdrawal from an account in credit
    Given I have deposited $100.00 in my account
    When I withdraw $20
    Then $20 should be dispensed
================
Text
----------------
4. 生成的Java Specification文件
================
Code
----------------
import cucumber.api.java.en.*;
import cucumber.api.Transform;

import org.junit.*;

import support.KnowsTheDomain;
import transforms.MoneyConverter;

public class AccountSteps {
  KnowsTheDomain helper;

  public AccountSteps(KnowsTheDomain helper) {
    this.helper = helper;
  }

  @Given("^I have deposited (\\$\\d+\\.\\d+) in my account$")
  public void iHaveDeposited$InMyAccount(@Transform(MoneyConverter.class) Money amount) 
                                                              throws Throwable {
    helper.getMyAccount().deposit(amount);

    Assert.assertEquals("Incorrect account balance -", amount, helper.getMyAccount().getBalance()); 
  }
}
import cucumber.api.java.en.*;

import org.junit.*;

import support.KnowsTheDomain;

import transforms.MoneyConverter;

public class CashSlotSteps {

  KnowsTheDomain helper;

  public CashSlotSteps(KnowsTheDomain helper) {
      this.helper = helper;
  }

  @Given("^\\$(\\d+) should be dispensed$")
  public void $ShouldBeDispensed(int dollars) throws Throwable {
    Assert.assertEquals("Incorrect amount dispensed -", dollars, 
                                    helper.getCashSlot().getContents());
  }
}
import cucumber.api.java.en.*;

import support.KnowsTheDomain;

public class TellerSteps {

  KnowsTheDomain helper;

  public TellerSteps(KnowsTheDomain helper) {
      this.helper = helper;
  }

  @When("^I withdraw \\$(\\d+)$")
  public void iWithdraw$(int amount) throws Throwable {
      helper.getTeller().withdrawFrom(helper.getMyAccount(), amount);
  }
}
================
Text
----------------
5. Cucumber 测试的运行入口
================
Code
----------------
import cucumber.api.junit.Cucumber;
import cucumber.api.CucumberOptions;
import cucumber.api.SnippetType;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(plugin="pretty", snippets=SnippetType.CAMELCASE)
public class RunCukesTest {
}
================
Text
----------------
6. 具体的实现
================
Code
----------------
public class Account {
    private Money balance = new Money();

    public void deposit(Money amount) {
        balance = balance.add(amount);
    }

    public Money getBalance() {
      return balance;
    }
}
public class CashSlot {
    private int contents;

    public int getContents() {
        return contents;
    }

    public void dispense(int dollars){
        contents = dollars;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class Money {
    private final int dollars;
    private final int cents;

    public Money() {
        this.dollars = 0;
        this.cents = 0;
    }

    public Money(int dollars, int cents) {
        this.dollars = dollars;
        this.cents = cents;
    }

    public Money(String amount) {
        Pattern pattern = Pattern.compile("^[^\\d]*([\\d]+)\\.([\\d][\\d])$");
        Matcher matcher = pattern.matcher(amount);

        matcher.find();
        this.dollars = Integer.parseInt(matcher.group(1));
        this.cents = Integer.parseInt(matcher.group(2));
    }

    public int dollars() {
        return dollars;
    }

    public int cents() {
        return cents;
    }

    public Money add(Money amount){
        int newCents = cents + amount.cents();
        int newDollars = dollars + amount.dollars();

        if (newCents >= 100){
            newCents -= 100;
            newDollars++;
        }

        return new Money(newDollars, newCents);
    }

    public Money minus(Money amount){
        int newCents = cents - amount.cents();
        int newDollars = dollars - amount.dollars();

        if (newCents < 0){
            newCents += 100;
            newDollars--;
        }

        return new Money(newDollars, newCents);
    }

    @Override
    public boolean equals(Object other){
        boolean equal = false;

        if (other instanceof Money){
            Money otherMoney = (Money)other;
            equal = (this.dollars() == otherMoney.dollars() 
                       && this.cents() == otherMoney.cents());
        }

        return equal;
    }

    @Override 
    public String toString() {
        return String.format("$%01d.%02d", this.dollars(), this.cents());
    } 
}
public class Teller {
    private CashSlot cashSlot;

    public Teller(CashSlot cashSlot) {
        this.cashSlot = cashSlot;
    }

    public void withdrawFrom(Account account, int dollars) {
        cashSlot.dispense(dollars);
    }
}
================
Text
----------------
从上面的例子可以看出，其实现的本质和原理如下：
夜深了，该睡了，行为驱动开发的介绍过一段落，行为驱动开发（BDD）你准备好了吗？
================
Title
----------------
【Windows 问题系列第 2 篇】如何让显示的窗口在桌面的最上面，而不被其它窗口遮挡？
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42351033/article/details/86297100
================
Stars
----------------
55
================
Text
----------------
这是【Windows 问题系列第 2 篇】，如果觉得有用的话，欢迎关注专栏。
有时候我们打开了一窗口，比如文本框 ，里面记了一些数据，但是一点其它窗口，要么文本框被其它窗口遮挡，要么直接就最小化了。
我们需要再看文本框里面的数据的时候，就需要再从任务栏里去重新点开它，很是麻烦。
这篇博客我教大家如何设置某个窗口在桌面的最上面，而不被其它窗口遮挡。
================
Header
----------------
文章目录
================
Header
----------------
一：下载、安装 DeskPins
================
Text
----------------
第一步：下载
直接访问这个 网址 下载。安装的时候一定要看好，把那些附带也要下载的软件给勾选掉。
有朋友反映(2021年12年07日)这个网址不提供下载了，所以我把我百度网盘上的分享出来了，
第二步：安装 安装软件，并解压文件夹，然后点击下图应用程序  单击后，软件就会运行，但是找不到运行的界面，因为这个小软件是没界面的，在桌面右下角的图标栏中可以找到，如下图所示
================
Header
----------------
二：如何使用 DeskPins
================
Text
----------------
第一步 这里我新建一个文本框，当做要一直显示在桌面最上方的窗口。
第二步 鼠标左击桌面右下角的图标栏中 DeskPins 图标，鼠标会变成一个白色钉子形状，把它移动到你想要固定的窗口上，再次点击鼠标左键，此时在窗口上会多出一个红色钉子图标，如下图所示  到这里，你再切换其它窗口，我们的窗口1便固定在了桌面的最上面。
================
Header
----------------
三：取消已经固定的窗口
================
Text
----------------
用鼠标左键点击红色钉子图标就可以了。
================
Header
----------------
四：设置多个固定窗口
================
Text
----------------
对新窗口，重复步骤1-4即可。如下图  你的问题得到解决了吗？欢迎在评论区留言。
赠人玫瑰，手有余香，如果觉得文章不错，希望可以给个一键三连，感谢。
================
Header
----------------
结束语
================
Title
----------------
[32] Window PowerShell DSC 学习系列----使用DSC Package安装时，如何获取Product ID？
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/77646554
================
Stars
----------------
1
================
Text
----------------
DSC的自身提供Package的DSC资源去安装msi格式的文件。 刚好笔者需要自动安装Chef的客户端，其就是一个msi格式的文件。但是有点复杂和烦人的是其需要使用这提供一个Product ID，其具体格式参考如下：  Package [string] #ResourceName  {  Name = [string]  Path = [string]  ProductId = [string]  [ Arguments = [string] ]  [ Credential = [PSCredential] ]  [ Ensure = [string] { Absent | Present } ]  [ LogPath = [string] ]  [ DependsOn = [string[]] ]  [ ReturnCode = [UInt32[]] ]  }  如果要安装Chef的客户端，其DSC的Configuration文件应该如下：
从上面看我们需要一个ProductID，但是目前没有直接的方法可以获取这个Product ID，一个的变通的方法是先安装上，然后通过Get-WmiObject Win32_Product 命令进行查看。  比如，
PS C:\Users\chancein007> Get-WmiObject Win32_Product -Filter “name like ‘%Chef%’”| Format-Table IdentifyingNumber, Name, Version
IdentifyingNumber Name Version  —————– —- ——-  {1EF1B367-A04C-4091-841C-8BCE15378EC0} Chef Client v13.1.31 13.1.31.1  {D4D32DC9-9CAF-46B6-AC52-376049930910} Chef Development Kit v0.17.17 0.17.17.1
而且这个Product ID是不会变化的，就是说这个安装包，装在任何一台机器上，其Product ID都是一样的，只要安装包一样。
================
Title
----------------
开发人员瑞士军刀---webtoolkitonline网站
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/79244164
================
Stars
----------------
0
================
Text
----------------
OpenSSL 是一个安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。那么在Window如何安装OpenSSL呢？在Linux上面好安装，直接在官网下载即可。
那在Windows操作系统该如何安装下载呢？  这个时候，大家就要到下面这个网站下载了。  https://slproweb.com/products/Win32OpenSSL.html
其提供Window 32位和64位的下载地址，现在完后可以直接安装，安装完后，把安装目录配置操作系统的环境变量path路径中，这样就能直接在命令行窗口中使用了。
================
Title
----------------
如何用Maven把依赖也打到可自动执行的jar里面？
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/chancein007/article/details/54389112
================
Stars
----------------
0
================
Text
----------------
最近笔者在用Maven打成一个可执行的jar包（包括main方法）的时候，遇到一个比较诡异的错误，Error: A JNI error has occurred, please check your installation and try again。下面是笔者的Manifest文件。那么如何解决呢？
================
Code
----------------
Manifest-Version: 1.0
Built-By: HenryZhu
Build-Jdk: 1.7.0_55
Class-Path: lib/junit-4.12.jar lib/hamcrest-core-1.3.jar lib/selenium-
 java-3.0.1.jar lib/selenium-chrome-driver-3.0.1.jar lib/selenium-remo
 te-driver-3.0.1.jar lib/selenium-api-3.0.1.jar lib/cglib-nodep-3.2.4.
 jar lib/commons-exec-1.3.jar lib/gson-2.3.1.jar lib/guava-19.0.jar li
 b/jna-platform-4.1.0.jar lib/jna-4.1.0.jar lib/selenium-edge-driver-3
 .0.1.jar lib/selenium-firefox-driver-3.0.1.jar lib/selenium-ie-driver
 -3.0.1.jar lib/selenium-opera-driver-3.0.1.jar lib/selenium-safari-dr
 iver-3.0.1.jar lib/netty-3.5.7.Final.jar lib/selenium-support-3.0.1.j
 ar lib/htmlunit-2.23.jar lib/xalan-2.7.2.jar lib/serializer-2.7.2.jar
  lib/commons-lang3-3.4.jar lib/httpclient-4.5.2.jar lib/httpcore-4.4.
 4.jar lib/httpmime-4.5.2.jar lib/commons-codec-1.10.jar lib/htmlunit-
 core-js-2.23.jar lib/neko-htmlunit-2.23.jar lib/xercesImpl-2.11.0.jar
  lib/xml-apis-1.4.01.jar lib/cssparser-0.9.20.jar lib/sac-1.3.jar lib
 /commons-io-2.5.jar lib/commons-logging-1.2.jar lib/phantomjsdriver-1
 .3.0.jar lib/websocket-client-9.2.15.v20160210.jar lib/jetty-util-9.2
 .15.v20160210.jar lib/jetty-io-9.2.15.v20160210.jar lib/websocket-com
 mon-9.2.15.v20160210.jar lib/websocket-api-9.2.15.v20160210.jar lib/h
 tmlparser-2.1.jar lib/htmllexer-2.1.jar lib/jgroups-3.0.11.Final.jar
Created-By: Apache Maven 3.3.9
Main-Class: com.winneryum.csdn.CSDNAutomationAccess
Archiver-Version: Plexus Archiver
================
Text
----------------
Manifest文件都是对的。指向的路径也是对的。但是在jar运行的时候，就是找不到jar文件里面的lib目录下的依赖的jar文件。
下面这个是笔者自己的在pom.xml文件中用的Build部分的plugin
================
Code
----------------
<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-dependency-plugin</artifactId>
				<executions>
					<execution>
						<id>copy-dependencies</id>
						<phase>prepare-package</phase>
						<goals>
							<goal>copy-dependencies</goal>
						</goals>
						<configuration>
							<outputDirectory>${project.build.directory}/classes/lib</outputDirectory>
							<overWriteReleases>false</overWriteReleases>
							<overWriteSnapshots>false</overWriteSnapshots>
							<overWriteIfNewer>true</overWriteIfNewer>
						</configuration>
					</execution>
				</executions>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-jar-plugin</artifactId>
				<configuration>
					<archive>
						<manifest>
							<mainClass>com.winneryum.csdn.CSDNAutomationAccess</mainClass>
							<addClasspath>true</addClasspath>  
                            <classpathPrefix>lib/</classpathPrefix>  
						</manifest>
					</archive>
				</configuration>
			</plugin>
		</plugins>
	</build>
================
Text
----------------
当前解决的方式，是用不要把把依赖的jar和可执行的jar放在一起，而是直接把依赖的jar文件，解压缩成class文件，然后和我们自己生成的代码放在一起，正确的pom.xml文件中用的Build部分的plugin应该如下：
================
Code
----------------
<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-dependency-plugin</artifactId>
				<version>2.4</version>
				<executions>
					<execution>
						<id>unpack-dependencies</id>
						<phase>prepare-package</phase>
						<goals>
							<goal>unpack-dependencies</goal>
						</goals>
						<configuration>
							<includes>**/*.class</includes>
							<excludes>**/*.properties</excludes>
							<outputDirectory>${project.build.outputDirectory}</outputDirectory>

						</configuration>
					</execution>
				</executions>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-jar-plugin</artifactId>
				<configuration>
					<archive>
						<manifest>
							<mainClass>com.winneryum.csdn.CSDNAutomationAccess</mainClass>
						</manifest>
					</archive>
				</configuration>
			</plugin>
		</plugins>
	</build>
================
Title
----------------
Python GUI之tkinter 实战（一）
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/78765890
================
Stars
----------------
75
================
Header
----------------
Python3 tkinter系列
================
Text
----------------
一、概述 二、布局管理 三、常用组件 四、实战（一） 五、实战（二） 六、进阶 自定义控件 推荐视频课程  tkinter从入门到实战
经过前几篇的基础学习，这一篇将综合运用组件，实战开发一个小工具，我们这个小工具是有一定实用意义的，不是假装写一个简单的登录窗口就完事了那种。
不知大家工作中使用过一个叫everything的工具没有，这是一个相当好用的工具，功能还挺多，没用过的话我就推荐一下，有哪些功能可以自行探索，我主要使用文件搜索功能，可以模糊搜索文件名，秒搜出路径，当你不记得曾下载的文件放哪去了的时候，你绝对需要这款神器，没错windows上的神器。我通常将everything搭配另一款windows神器FileLocator Pro 一起使用，这真的是用windows系统的程序员神器，FileLocator Pro是用来快速搜索文本文件内容的，一个搜索文件名另一个搜索文件内容，搭配使用，我感觉比source insight要好用一点，因为我工作电脑上通常有将近十套Android源码，不同芯片厂商和不同版本，一套源码多大，几十个G，用source insight必须要创建索引，建立数据库，对于我来说太过于笨重了，扯远了，总之就是everything + FileLocator Pro 源码跟踪神器，那么我们今天就用tkinter模仿做一个超简单版everything 。
everything界面：
上我们tkinter的界面：
上代码之前，先说一点，我这里使用了一点ttk，什么是ttk？其实我觉得可以理解为对控件的一个美化。因为一些原因，tkinter做出的界面感年代久远，于是出现了这么一个ttk的东西，让界面风格可以更接近当前的系统平台，相当于稍稍美化一下，实际上与之前博客讲的控件使用没有什么区别，只是多导一个包
================
Code
----------------
from tkinter import *
from tkinter import ttk
import tkinter.filedialog as dir

class AppUI():

    def __init__(self):
        root = Tk()
        self.create_menu(root)
        self.create_content(root)
        self.path = 'C:'
        root.title("磁盘文件搜索工具")
        root.update()
        # root.resizable(False, False) 调用方法会禁止根窗体改变大小
        #以下方法用来计算并设置窗体显示时，在屏幕中心居中
        curWidth = root.winfo_width()  # get current width
        curHeight = root.winfo_height()  # get current height
        scnWidth, scnHeight = root.maxsize()  # get screen width and height
        tmpcnf = '+%d+%d' % ((scnWidth - curWidth) / 2, (scnHeight - curHeight) / 2)
        root.geometry(tmpcnf)
        root.mainloop()

    def create_menu(self,root):
        #创建菜单栏
        menu = Menu(root)

        #创建二级菜单
        file_menu = Menu(menu,tearoff=0)
        file_menu.add_command(label="设置路径",command=self.open_dir)
        file_menu.add_separator()

        scan_menu = Menu(menu)
        file_menu.add_command(label="扫描")

        about_menu = Menu(menu,tearoff=0)
        about_menu.add_command(label="version:1.0")

        #在菜单栏中添加以下一级菜单
        menu.add_cascade(label="文件",menu=file_menu)
        menu.add_cascade(label="关于",menu=about_menu)
        root['menu'] = menu

    def create_content(self, root):
        lf = ttk.LabelFrame(root, text="文件搜索")
        lf.pack(fill=X, padx=15, pady=8)

        top_frame = Frame(lf)
        top_frame.pack(fill=X,expand=YES,side=TOP,padx=15,pady=8)

        self.search_key = StringVar()
        ttk.Entry(top_frame, textvariable=self.search_key,width=50).pack(fill=X,expand=YES,side=LEFT)
        ttk.Button(top_frame,text="搜索",command=self.search_file).pack(padx=15,fill=X,expand=YES)

        bottom_frame = Frame(lf)
        bottom_frame.pack(fill=BOTH,expand=YES,side=TOP,padx=15,pady=8)

        band = Frame(bottom_frame)
        band.pack(fill=BOTH,expand=YES,side=TOP)

        self.list_val = StringVar()
        listbox = Listbox(band,listvariable=self.list_val,height=18)
        listbox.pack(side=LEFT,fill=X,expand=YES)

        vertical_bar = ttk.Scrollbar(band,orient=VERTICAL,command=listbox.yview)
        vertical_bar.pack(side=RIGHT,fill=Y)
        listbox['yscrollcommand'] = vertical_bar.set

        horizontal_bar = ttk.Scrollbar(bottom_frame,orient=HORIZONTAL,command=listbox.xview)
        horizontal_bar.pack(side=BOTTOM,fill=X)
        listbox['xscrollcommand'] = horizontal_bar.set

        #给list动态设置数据，set方法传入一个元组，注意此处是设置，不是插入数据，此方法调用后，list之前的数据会被清除
        self.list_val.set(('jioj',124,"fjoweghpw",1,2,3,4,5,6))

    def search_file(self):
        pass

    def open_dir(self):
        d = dir.Directory()
        self.path = d.show(initialdir=self.path)


if __name__ == "__main__":
    AppUI()
================
Text
----------------
首先创建一个AppUI类，类似的GUI项目，肯定是使用面向对象的思维，这里在构造方法中做了一些初始化，以及根窗体属性的设置。并通过两个方法来创建主要界面
这里给一个官方示例
如上图，最外层是ttk中的LabelFrame，这个控件是一个带边框效果的Frame，其次是top_frame，它用来盛放单行文本框与搜索按钮，紧接其下的是bottom_frame，它用来盛放搜索的列表框，在bottom_frame中又添加了一层band，它是直接用来放Listbox控件与垂直方向的Scrollbar，即一个滚动条，这里为什么要加一层band呢？因为pack布局的简单性，它无法用来将Listbox与横纵两个方向的滚动条组合起来，它一次只能组合一个。
实际上组合横纵两个滚动条可以使用grid布局，但是对于根窗体可自由拉伸时的支持效果感觉不太好，且此处也是着重用来讲解分层布局，所以未使用，但此处仍然给出一个官方示例  此示例与组合横纵两个滚动条稍有出入，但其实将位于底部的Sizegrip组件换成水平方向Scrollbar就行
关于Listbox与Scrollbar的简单使用，可查看官方文档的示例（ Python GUI之tkinter 常用组件这篇博客已经给出官方文档下载路径，不再赘述），最后简述一下关于打开文件夹对话框的问题
Python2.x版本中使用的tkFileDialog 在Python3.x版本已经不能使用，替代的是tkinter.filedialog，该模块封装了一些文件对话框的操作，但是此次我并没有使用filedialog的askdirectory函数来打开一个文件夹选择对话框，原因是该封装过于死板，无法实现一个小功能，即上次打开一个文件夹路径，希望能记住这个路径，下次打开仍是这个路径。
askdirectory使用如下：
================
Code
----------------
import tkinter.filedialog as dir
#initialdir 属性为传入默认打开的路径
path = dir.askdirectory(initialdir=r"C:\Windows")
================
Text
----------------
我工程使用的方式通过Directory类实现，每次打开时传入一个默认路径
================
Code
----------------
def open_dir(self):
        d = dir.Directory()
        self.path = d.show(initialdir=self.path)
================
Text
----------------
好了，界面的部分先到这里，下一篇博客着重于功能的实现，以及UI线程与异步线程的交互
================
Title
----------------
Adversarial Heterogeneous Network Embedding with Metapath Attention Mechanism
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/algzjh/article/details/107301002
================
Stars
----------------
1
================
Text
----------------
论文传送门
================
Header
----------------
作者
================
Text
----------------
复旦大学
国防科技大学
澳大利亚联邦大学
================
Header
----------------
摘要
================
Text
----------------
异构信息网络（HIN） 为真实世界中的实际应用提供了有效的模型。网络嵌入是支持基于网络的分析和预测任务的基础。当前流行的网络嵌入方法通常无法有效保留HIN的语义。在这个研究中，我们提出了AGA2Vec，这是一种用于HIN嵌入的生成对抗模型，它使用注意力机制和元路径。为了从HIN中的多类型实例和关系中捕获语义信息，我们研发了加权元路径策略来保持HIN邻近性。然后，我们使用自动编码器和生成对抗模型来获得HIN的可靠表示形式。在多个实际数据集上的实验结果表明，该方法胜过HIN嵌入的最新方法。
================
Header
----------------
研究问题
================
Text
----------------
网络嵌入是支持基于网络的分析和预测任务的基础。当前普遍流行的网络嵌入方法无法有效地保留异构信息网络的语义。
================
Header
----------------
解决办法
================
Text
----------------
核心框架如下：
================
Header
----------------
贡献
================
Header
----------------
实验
================
Text
----------------
数据集：
Baseline:
================
Header
----------------
思考
================
Text
----------------
Critical thinking: baseline中采用的embedding方法可以有更新的
Creative thinking: 利用 negative sampling 加速训练
How to apply to our work: 实验部分的Node Clustering、Link Prediction值得借鉴，要用数据说话。 测试Scalability时采用对数
================
Title
----------------
Python GUI之tkinter 实战（二）tkinter+多线程
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/78838395
================
Stars
----------------
158
================
Header
----------------
Python3 tkinter系列
================
Text
----------------
一、概述 二、布局管理 三、常用组件 四、实战（一） 五、实战（二） 六、进阶 自定义控件 推荐视频课程  tkinter从入门到实战
================
Header
----------------
自定义对话框
================
Text
----------------
在继续上一篇博客之前，先讲一个东西，这个东西我们待会儿就需要用到
在tkinter中，根窗口只能有一个，也就是通过Tk()方法创建的实例对象。如果需要创建多个窗口该怎么办呢？那就需要使用另一个控件——Toplevel
在第一篇概述的主要控件列表中，我已经列出来了
实际上该控件可以当做一个根窗体去使用，API是相同的，想要实现多个窗口，必须使用该控件才能实现
================
Code
----------------
from tkinter import *
from tkinter import ttk

class GressBar():

	def start(self):
		top = Toplevel()
		self.master = top
		top.overrideredirect(True)
		top.title("进度条")
		Label(top, text="任务正在运行中,请稍等……", fg="green").pack(pady=2)
		prog = ttk.Progressbar(top, mode='indeterminate', length=200)
		prog.pack(pady=10, padx=35)
		prog.start()

		top.resizable(False, False)
		top.update()
		curWidth = top.winfo_width()
		curHeight = top.winfo_height()
		scnWidth, scnHeight = top.maxsize() 
		tmpcnf = '+%d+%d' % ((scnWidth - curWidth) / 2, (scnHeight - curHeight) / 2)
		top.geometry(tmpcnf)
		top.mainloop()

	def quit(self):
		if self.master:
			self.master.destroy()
================
Text
----------------
如上代码，实际上与我们上一篇创建界面的代码没有什么不同，只是将Tk换成了Toplevel，有一点要说明，上述代码中调用了窗体的overrideredirect()方法，该方法可以去除窗体的边框，效果如上图，没有了最大最小以及关闭按钮
这里有一点必须特别注意，如果在代码中直接使用Toplevel而不创建Tk根窗体，仍然会有一个默认的根窗体，也就是说Toplevel必须依赖根窗体而存在。如果从我们已创建的根窗体启动Toplevel，则它依赖的就是我们所创建的那个根窗体，因此使用该控件时，最好有一个已创建的根窗体
到这里，我们就已经自定义好了一个tkinter的进度条控件，在做磁盘文件扫描时，会比较耗时，因此最好能有一个进度条控件。
================
Header
----------------
tkinter的UI线程与异步线程
================
Text
----------------
如下，我们运行一段程序
================
Code
----------------
a = input('请输入：')
print(a)
================
Text
----------------
执行上面的代码，在命令行界面，会等待用户输入，当我们输入一个内容，将会立刻打印该内容，但是当我们继续输入内容的时候，为什么命令行就没有任何反应了呢？其实原因很简单，当执行完print函数时，代码就已经全部执行完毕，程序结束了，程序都结束了，当然不会再响应你的输入了。
那么我们有没有这样一个疑问，为什么我们在操作带界面的程序时，只要不手动点击退出，它可以一直响应用户的各种操作呢？我们似乎感觉它即使执行完了你的一个点击操作，程序也不会退出，它仍然在随时待命，等待你给的指令。对，抓住这一点灵感，那就是它一直不退出，在Python基础时，我们就知道，一直不退出的程序，那只有死循环！于是我们改进上述代码
================
Code
----------------
while 1:
    a = input('请输入：')
    print(a)
================
Text
----------------
Ok，让我们再次运行上述代码，终于可以实现随时待命的程序了！但是有一点不爽，那就是当我们不想玩了的时候，我们似乎没法退出，当然我指的可不是关电脑！这就好像一个界面程序，他的边框上没有那个小×按钮，这真是让人郁闷难受，我们必须要加上这个×按钮，当然，命令行是没有按钮的，命令行通常用q命令或者exit退出，我们权且把q命令当做×按钮吧
================
Code
----------------
while 1:
    a = input('请输入：')
    if a == 'q':
        break
    print(a)
================
Text
----------------
怎么样，修改后的代码是不是模拟了界面程序的操作流程？实际上GUI程序的原理就和上面这几行代码表达的是一样的，GUI程序必然也有一个死循环，而这个循环所干的事情就是不断的绘制当前的界面，或者说是更新界面。如果去玩一下pygame库，那就一定体会更深了。毋庸置疑，这个循环所在的线程就是UI线程，或者说是程序的主线程。到这里，我们应该终于能明白mainloop()方法的意义了吧，调用它就代表正式进入程序的主循环，所以不调用mainloop，界面就不会被创建出来。
既然在UI线程主要负责界面的绘制与更新，那么如果在UI线程进行耗时操作，势必影响UI操作的流畅性，这也就是为什么我们要另起异步线程干活的原因所在。但是另起异步线程，不可避免的要面对异步线程与主线程交互的问题，也就是两个线程之间的通信。为什么一定要通信呢？因为在几乎所有的GUI界面编程中，异步线程是不能去操作更新当前的界面的，否则就会造成界面混乱。这很好理解，两个不同线程操作相同资源，必然是会造成混乱的，界面毕竟是在主线程创建的，当然内在原因也不仅仅是这么简单，但我们这样去理解是没错的。然而tkinter中并没有提供好的工具，因此我们只能自行实现。
这里我们通过消息队列的方式来简单实现一下，会用到Queue类，该类的相关API可查阅Pyhton文档，实际上该类就是一个队列，此处就在上一篇博客内容中的代码添加，无关代码省略
================
Code
----------------
from tkinter import *
from tkinter import ttk
import tkinter.filedialog as dir
import progressbar
import queue

class AppUI():

    def __init__(self):
	    #创建一个消息队列
        self.notify_queue = queue.Queue()
        root = Tk()
        self.master = root
        self.create_menu(root)
        self.create_content(root)
        self.path = 'C:'
        root.title("磁盘文件搜索工具")
		………省略………
		#创建一个进度条对话框实例
		self.gress_bar = progressbar.GressBar()
		#在UI线程启动消息队列循环
		self.process_msg()
        root.mainloop()

    def process_msg(self):
        self.top.after(400,self.process_msg)
        while not self.notify_queue.empty():
            try:
                msg = self.notify_queue.get()
                if msg[0] == 1:
                     self.gress_bar.quit()

            except queue.Empty:
                pass
================
Text
----------------
在上面代码中，我们首先创建了一个消息队列self.notify_queue，接下来使用了上文我们自定义的进度条对话框，给自定义进度条对话框的代码创建一个模块progressbar，然后导入这个模块中的GressBar即可。
接下来最关键的部分在self.process_msg()方法，我们定义了一个process_msg方法，并在进入主循环前调用了它。看到方法的具体实现，我们首先调用了根窗体的after()方法，这个方法实际上相当于一个定时器，它第一个参数传的是时间的毫秒值，第二个参数指定执行一个函数，也就是说，该方法可以定时的让主循环去执行一个函数（只会执行一次哦），此处我们传入的是self.process_msg，也就是仍然调用自己，这里相当于递归，实际上方法的递归也就是一种是循环了，每隔400毫秒执行一下自己。
process_msg方法的最后，也就是对队列的操作了，其实Queue的方法也都很好理解，通过方法名我们大致都知道是什么意思了。这里首先通过empty方法判断一下队列是否为空，如果不为空就进入while循环，然后就从队列中取出第一条消息msg，此处我们定义往消息队列中存入元组，元组第一个元素用来表示消息类型，这里判断，如果消息类型为1，就关闭进度条对话框，执行完了这一条消息，就继续判断队列是否仍有消息，如果有就继续从消息队列里面取出第二条消息执行，若无消息则退出while循环。这样我们就在主线程建立了一个消息队列，每隔一段时间去消息队列里看看，有没有什么消息是需要主线程去做的，有一点需要特别注意，主线程消息队列里也不要干耗时操作，该队列仅仅用来更新UI。
关于Python起线程的方法，和java倒有一点相似，都有两种形式，一种是定义一个类继承Thread类并实现run方法，一种是直接创建Thread类实例并传入需要被执行的方法。这些都属于Python基础知识，不再赘述。 在代码中添加如下方法：
================
Code
----------------
def execute_asyn(self):
	    #定义一个scan函数，放入线程中去执行耗时扫描
        def scan(_queue):
            pass
            _queue.put((1,))

        th = threading.Thread(target=scan,args=(self.notify_queue,))
        th.setDaemon(True)
        th.start()
        #启动进度条
        self.gress_bar.start()
================
Text
----------------
具体scan扫描代码还未实现，但是架子基本就是这样了。 首先绑定调用的函数：
================
Code
----------------
file_menu.add_command(label="扫描",command=self.execute_asyn)
================
Text
----------------
我们这里通过模拟耗时操作验证一下，加一点测试代码
================
Code
----------------
#定义一个scan函数，放入线程中去执行耗时扫描
        def scan(_queue):
            time.sleep(2) #让线程睡眠2秒
            _queue.put((1,))
================
Text
----------------
另外补充一点，队列嘛，当然都是单向的，就像人在操场排队，肯定都是朝向主席台一个方向咯，这里我们只说明了异步线程主动去联系主线程，还没有主线程去联系异步线程，这个其实也很简单了，一个队列当然只能管一边，我们按图索骥，再创建一个队列，通过两个队列，就能实现两个线程的沟通了。
================
Header
----------------
实现磁盘文件快速搜索
================
Text
----------------
实际上everything原理也很简单，它所谓的秒搜功能，实际上只是在启动的时候将所有磁盘文件的路径信息存入本地数据库中，当用户需要搜索时只需要检索数据库就行，我们知道，数据库的检索是相当快速的，几乎就等同于秒搜了，但是这样实现也有一些缺陷，那就是当你不断下载大量的小文件时，检索工具的数据库需要不断更新，否则最新下载的文件是搜索不到的，往往这个时候会造成磁盘的卡顿，当然everything中也不是如此简单，其中也肯定会有一些算法来优化性能，现在我们只是简单模仿一些，做为tkinter的一个实战练习
这次我们使用的是SQLite数据库，相信有移动开发经验的都相当熟悉了，之所以使用它，因为它是如此的简单，无需各种配置，操作它只相当于操作一个文件，且性能也相当不错，完全满足我们的需求。
好了，上代码 创建一个disk.py文件
================
Code
----------------
import os
import os.path as pt

def scan_file(path):
    result = []
    for root,dirs,files in os.walk(path):
        for f in files:
            file_path = pt.abspath(pt.join(root,f))

            result.append((file_path,file_path[0])) #保存路径与盘符

    return result
================
Text
----------------
os.walk函数用来遍历一个给定路径下的所有文件，通常这种磁盘文件遍历，都需要写递归实现，但是Python就是这么的强大，直接提供了这样一个生成器函数，从这一个个小点就可以看出，写Python代码能省多少事，多少心！
实际上，上述代码我们是可以通过列表生成式用一行代码表达，但是作为一个长期写java的程序员，这也正是我要吐槽的地方，Python的这些语法糖，我认为往往是毒药，极大的破坏了代码的可读性，简洁只是对于写代码的人而言，对于大量阅读Python代码的人往往是灾难！我始终秉持的一个观点就是，代码是写给人看的，绝不是给机器看的，机器只认二进制！所以我认为任何破坏代码可读性的无意义的语法糖就是毒药！或许只有接手过烂代码维护的人才懂得什么叫问候对方八辈祖宗，对于大型工程生命而言，代码可读性扩展性真的是第一重要的。
Python中还有很多类似的用一句话表达一些逻辑的语法糖，可自行体会 这里还是给出列表生成式的写法
================
Code
----------------
def scan_file(path):
    return [(pt.abspath(pt.join(root,f)),pt.abspath(pt.join(root,f))[0]) for root,dirs,files in os.walk(path) for f in files]
================
Text
----------------
上面代码的主要功能就是扫描文件，并将路径与盘符存到一个列表中返回
下面是写入数据库的代码，创建一个database.py文件
================
Code
----------------
import sqlite3

class DataMgr():

    def __init__(self):
	    #创建或打开一个数据库
        self.conn = sqlite3.connect("file.db",check_same_thread=False)
		#创建表
        self.conn.execute('create table if not exists disk_table('\
                        'id integer primary key autoincrement,'\
                        'file_path text,'\
                        'drive_letter text)')
		#创建索引，主要用来提高搜索速度
        self.conn.execute('create index if not exists index_path on disk_table (file_path)')

	#批量插入数据
    def batch_insert(self,data):
        for line in data:
            self.conn.execute("insert into disk_table values (null,?,?)",line)

        self.conn.commit()

	#模糊搜索
    def query(self,key):
        cursor = self.conn.cursor()

        cursor.execute("select file_path from disk_table where file_path like ?",('%{0}%'.format(key),))
        r = [row[0] for row in cursor]
        cursor.close()
        return r

    def close(self):
        self.conn.close()
================
Text
----------------
关于sql语言的内容，不是本文的范畴，需要掌握基本的sql知识，特别是SQLite的使用，不过Python文档中已经给出了详细示例，可自行学习，这里推荐看我新写的博客入门 Python小白的数据库入门  修改异步任务与搜索代码：
================
Code
----------------
def execute_asyn(self):
        #定义一个scan函数，放入线程中去执行耗时扫描
        def scan(_queue):
            if self.path:
                paths = disk.scan_file(self.path)
                self.data_mgr.batch_insert(paths)

            _queue.put((1,))

        th = threading.Thread(target=scan,args=(self.notify_queue,))
        th.setDaemon(True)
        th.start()
        #启动进度条
        self.gress_bar.start()

    def search_file(self):
        if self.search_key.get():
            result_data = self.data_mgr.query(self.search_key.get())
            if result_data:
                self.list_val.set(tuple(result_data))
================
Text
----------------
到此基本功能完成，有一点需要说明，为了追求代码逻辑尽量简单，这里的实现也是有一些问题的，比如数据库是在主线程创建的，IO操作可能会耗时，影响界面流畅，且在主线程创建，在子线程操作也是有一点问题的，故设置了check_same_thread属性来规避多线程操作数据库的问题。
首先我们通过设置菜单设置一个文件较少的路径，减少测试耗时，然后通过扫描菜单完成数据的初始化加载，最后就可以在搜索框愉快的搜索文件了，如果想要全硬盘搜索，建议使用多线程，分别分配给不同的线程去扫描不同的磁盘用以提升速度，另外磁盘操作属于IO密集型，多线程的方式足矣，如果是计算密集型，则建议多进程方式，因为Python是假的多线程，所以往往习惯多进程的方式，实际上IO密集型的任务，Python的多线程是够用的
到此tkinter系列的几篇博客结束，实际上只是大体写了一下tkinter怎么玩，但我觉得这些已经足够了，剩下的只是一些组件的具体api，通过自行查文档的方式基本无压力，这里过滤了tkinter的事件处理部分，因为我觉得tkinter的事件处理部分实在太小儿科，而且也并没有什么卵用，通过command属性关联函数基本就可以实现点击事件，够用，且tkinter提供的功能相对比较弱，真正需要去处理键盘与鼠标各按键的时候，我想是不会去用tkinter库的，因为有这种需求的往往是功能比较复杂的应用，况且事件处理这一块也是比较简单的，看一下文档也基本搞定了。
有一点东西想要补充一下，在ttk模块中，为tkinter添加了一下新的控件，这些在我们第一篇博客概述中是没有罗列的，我感觉意义好像不太大，但有个东西我想提一下，就是Notebook控件，它其实就是一个选项卡控件，这个控件使用异常简单，但是对界面的设计还是有很大好处的，使用它可以让界面更加简洁美观，如何使用，只需看一下文档即可，非常简单，下面给出一张ttk新增控件目录
最后给出完整的主界面模块代码：
================
Code
----------------
from tkinter import *
from tkinter import ttk
import tkinter.filedialog as dir
from database import DataMgr
import queue,progressbar,threading,disk

class AppUI():

    def __init__(self):
        self.notify_queue = queue.Queue()
        root = Tk()
        self.master = root
        self.create_menu(root)
        self.create_content(root)
        self.path = 'C:'
        root.title("磁盘文件搜索工具")
        root.update()
        # root.resizable(False, False) 调用方法会禁止根窗体改变大小
        #以下方法用来计算并设置窗体显示时，在屏幕中心居中
        curWidth = root.winfo_width()
        curHeight = root.winfo_height()
        scnWidth, scnHeight = root.maxsize()
        tmpcnf = '+%d+%d' % ((scnWidth - curWidth) / 2, (scnHeight - curHeight) / 2)
        root.geometry(tmpcnf)

        self.gress_bar = progressbar.GressBar()
        self.data_mgr = DataMgr()
        self.process_msg()
        root.mainloop()

    def create_menu(self,root):
        #创建菜单栏
        menu = Menu(root)

        file_menu = Menu(menu,tearoff=0)
        # 创建二级菜单
        file_menu.add_command(label="设置路径",command=self.open_dir)
        file_menu.add_separator()
        file_menu.add_command(label="扫描",command=self.execute_asyn)

        about_menu = Menu(menu,tearoff=0)
        about_menu.add_command(label="version:1.0")

        #在菜单栏中添加菜单
        menu.add_cascade(label="文件",menu=file_menu)
        menu.add_cascade(label="关于",menu=about_menu)
        root['menu'] = menu

    def create_content(self, root):
        lf = ttk.LabelFrame(root, text="文件搜索")
        lf.pack(fill=X, padx=15, pady=8)

        top_frame = Frame(lf)
        top_frame.pack(fill=X,expand=YES,side=TOP,padx=15,pady=8)

        self.search_key = StringVar()
        ttk.Entry(top_frame, textvariable=self.search_key,width=50).pack(fill=X,expand=YES,side=LEFT)
        ttk.Button(top_frame,text="搜索",command=self.search_file).pack(padx=15,fill=X,expand=YES)

        bottom_frame = Frame(lf)
        bottom_frame.pack(fill=BOTH,expand=YES,side=TOP,padx=15,pady=8)

        band = Frame(bottom_frame)
        band.pack(fill=BOTH,expand=YES,side=TOP)

        self.list_val = StringVar()
        listbox = Listbox(band,listvariable=self.list_val,height=18)
        listbox.pack(side=LEFT,fill=X,expand=YES)

        vertical_bar = ttk.Scrollbar(band,orient=VERTICAL,command=listbox.yview)
        vertical_bar.pack(side=RIGHT,fill=Y)
        listbox['yscrollcommand'] = vertical_bar.set

        horizontal_bar = ttk.Scrollbar(bottom_frame,orient=HORIZONTAL,command=listbox.xview)
        horizontal_bar.pack(side=BOTTOM,fill=X)
        listbox['xscrollcommand'] = horizontal_bar.set

        #给list动态设置数据，set方法传入一个元组，注意此处是设置，不是插入数据，此方法调用后，list之前的数据会被清除
        self.list_val.set(('jioj',124,"fjoweghpw",1,2,3,4,5,6))

    def process_msg(self):
        self.master.after(400,self.process_msg)
        while not self.notify_queue.empty():
            try:
                msg = self.notify_queue.get()
                if msg[0] == 1:
                    self.gress_bar.quit()

            except queue.Empty:
                pass

    def execute_asyn(self):
        #定义一个scan函数，放入线程中去执行耗时扫描
        def scan(_queue):
            if self.path:
                paths = disk.scan_file(self.path)
                self.data_mgr.batch_insert(paths)

            _queue.put((1,))

        th = threading.Thread(target=scan,args=(self.notify_queue,))
        th.setDaemon(True)
        th.start()
        #启动进度条
        self.gress_bar.start()

    def search_file(self):
        if self.search_key.get():
            result_data = self.data_mgr.query(self.search_key.get())
            if result_data:
                self.list_val.set(tuple(result_data))

    def open_dir(self):
        d = dir.Directory()
        self.path = d.show(initialdir=self.path)

if __name__ == "__main__":
    AppUI()
================
Title
----------------
Python 流媒体播放器（基于VLC）
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/89527561
================
Stars
----------------
147
================
Header
----------------
文章目录
================
Text
----------------
VLC就是我们今天的主角。官网地址： 点击我
根据官网的介绍，它是一款自由、开源的跨平台多媒体播放器及框架，它全面支持绝大部分的多媒体格式，以及各类流媒体协议。也就是说，使用它既能播放本地音视频文件，也能在线播放各类流媒体资源。
这是目前全网最全面的一篇关于VLC的Python语言绑定的使用教程，本人浏览了其API文档，从文档中直接提炼出了Python语言绑定的使用方法，本篇以Windows平台为主，如果读者朋友觉得有用，请点赞支持！
================
Header
----------------
环境准备
================
Text
----------------
更新：
对于很多人反应各种动态库报错问题，首先说明一点，严格按照本文步骤操作，其次，作为Python开发者，应当有版本兼容问题的觉悟。本文写作时，Python3.8版本尚未正式发布，后面许多人使用Python3.8及其之后版本运行本文示例，导致加载动态库存在问题。具体问题原因早在博主GitHub 仓库已经提出了，见 issues/1
================
Header
----------------
VLC 安装
================
Text
----------------
VLC实际上是比较知名的开源多媒体播放器，要使用这个库，首先需要在电脑上安装VLC，我们可以直接在上述的官网中下载并安装它，有一点需要特别注意，如果本地安装的Python是32位，则你必须下载32位的VLC，64位则下64位的VLC，必须与Python的版本对应，否则无法使用。
事实上，我并不推荐这样直接安装。试想一下，如果我们使用Python开发一个基于VLC的播放器发布出去，却要求用户在使用之前，先安装一个VLC播放器，岂不是很荒谬？那么如何将VLC集成到Python程序中来，才是问题的关键。
关于这个问题，没有找到相关资料，只能通过查看python-vlc绑定的源码来寻找方法。
================
Header
----------------
安装python-vlc 绑定
================
Text
----------------
VLC是纯C语言开发的框架，Python想要更简单的调用，需要安装一个python-vlc 绑定，实际上就是一个vlc.py模块，它封装了VLC动态库的接口，让我们使用更简单。
================
Code
----------------
python -m pip install python-vlc
================
Text
----------------
完成安装后，我们在site-packages中找到vlc.py源码，查看其对VLC动态库的加载代码，可以发现，在Windows系统上，vlc.py是通过查询Windows注册表的方式来搜索路径并加载VLC的dll动态库的。但它其中也提供了一个配置环境变量PYTHON_VLC_MODULE_PATH的加载方式，这样我们就能在尽可能不修改vlc.py源码的前提下完成VLC动态库的集成。
好了，到这里，我们只需要去下载一个VLC的绿色免安装版本即可。由于我的Python环境是64位，这里给出一个Windows 64位下载地址：点我 选择vlc-3.0.6-win64.7z即可
下载完成后，解压目录，进入其中，删除无关内容，保留如下文件
其中plugins中的内容非常多，达到122M，我们可以根据实际情况进行剪裁，例如我们只需要做一个音频播放器，则可将其中的video相关的文件夹删除，还包括gui文件夹，因为我们要自己做界面，不需要gui里面的qt相关的dll。
================
Header
----------------
简单播放示例
================
Text
----------------
创建一个Python工程，将已经剪裁好的vlc-3.0.6文件夹拷贝到工程根目录。然后创建一个python脚本，我们对vlc.py再次封装
================
Code
----------------
import os, time

# 设置VLC库路径，需在import vlc之前
os.environ['PYTHON_VLC_MODULE_PATH'] = "./vlc-3.0.6"

import vlc

class Player:
    '''
        args:设置 options
    '''
    def __init__(self, *args):
        if args:
            instance = vlc.Instance(*args)
            self.media = instance.media_player_new()
        else:
            self.media = vlc.MediaPlayer()

    # 设置待播放的url地址或本地文件路径，每次调用都会重新加载资源
    def set_uri(self, uri):
        self.media.set_mrl(uri)

    # 播放 成功返回0，失败返回-1
    def play(self, path=None):
        if path:
            self.set_uri(path)
            return self.media.play()
        else:
            return self.media.play()

    # 暂停
    def pause(self):
        self.media.pause()

    # 恢复
    def resume(self):
        self.media.set_pause(0)

    # 停止
    def stop(self):
        self.media.stop()

    # 释放资源
    def release(self):
        return self.media.release()

    # 是否正在播放
    def is_playing(self):
        return self.media.is_playing()

    # 已播放时间，返回毫秒值
    def get_time(self):
        return self.media.get_time()

    # 拖动指定的毫秒值处播放。成功返回0，失败返回-1 (需要注意，只有当前多媒体格式或流媒体协议支持才会生效)
    def set_time(self, ms):
        return self.media.get_time()

    # 音视频总长度，返回毫秒值
    def get_length(self):
        return self.media.get_length()

    # 获取当前音量（0~100）
    def get_volume(self):
        return self.media.audio_get_volume()

    # 设置音量（0~100）
    def set_volume(self, volume):
        return self.media.audio_set_volume(volume)

    # 返回当前状态：正在播放；暂停中；其他
    def get_state(self):
        state = self.media.get_state()
        if state == vlc.State.Playing:
            return 1
        elif state == vlc.State.Paused:
            return 0
        else:
            return -1

    # 当前播放进度情况。返回0.0~1.0之间的浮点数
    def get_position(self):
        return self.media.get_position()

    # 拖动当前进度，传入0.0~1.0之间的浮点数(需要注意，只有当前多媒体格式或流媒体协议支持才会生效)
    def set_position(self, float_val):
        return self.media.set_position(float_val)

    # 获取当前文件播放速率
    def get_rate(self):
        return self.media.get_rate()

    # 设置播放速率（如：1.2，表示加速1.2倍播放）
    def set_rate(self, rate):
        return self.media.set_rate(rate)

    # 设置宽高比率（如"16:9","4:3"）
    def set_ratio(self, ratio):
        self.media.video_set_scale(0)  # 必须设置为0，否则无法修改屏幕宽高
        self.media.video_set_aspect_ratio(ratio)

    # 注册监听器
    def add_callback(self, event_type, callback):
        self.media.event_manager().event_attach(event_type, callback)

    # 移除监听器
    def remove_callback(self, event_type, callback):
        self.media.event_manager().event_detach(event_type, callback)
================
Text
----------------
调用代码
================
Code
----------------
def my_call_back(event):
    print("call:", player.get_time())

if "__main__" == __name__:
    player = Player()
    player.add_callback(vlc.EventType.MediaPlayerTimeChanged, my_call_back)
    # 在线播放流媒体视频
    player.play("http://hd.yinyuetai.com/uploads/videos/common/"
                                 "22970150925A6BB75E20D95798D129EE.flv?sc\u003d17d6a907580e9892"
                                 "\u0026br\u003d1103\u0026vid\u003d2400382\u0026aid\u003d32"
                                 "\u0026area\u003dML\u0026vst\u003d0")

    # 播放本地mp3
    # player.play("D:/abc.mp3")

    # 防止当前进程退出
    while True:
        pass
================
Header
----------------
VLC 监听器
================
Text
----------------
上面代码中，我们注册了MediaPlayerTimeChanged类型的监听器，表示已播放时间变化时回调，可以看到my_call_back会不断回调，因为每播放一点都会回调。
除了上述的监听器，VLC的监听器实际上非常多，常见的我们列举如下：
要查看全部支持的监听器，请访问 官方文档 并搜索EventType类型查看
================
Header
----------------
视频加字幕
================
Text
----------------
在我们上述封装的Player类中添加如下方法
================
Code
----------------
def set_marquee(self):
        self.media.video_set_marquee_int(vlc.VideoMarqueeOption.Enable, 1)
        self.media.video_set_marquee_int(vlc.VideoMarqueeOption.Size, 28)
        self.media.video_set_marquee_int(vlc.VideoMarqueeOption.Color, 0xff0000)
        self.media.video_set_marquee_int(vlc.VideoMarqueeOption.Position, vlc.Position.Bottom)
        self.media.video_set_marquee_int(vlc.VideoMarqueeOption.Timeout, 0)
        self.media.video_set_marquee_int(vlc.VideoMarqueeOption.Refresh, 10000)

    def update_text(self, content):
        self.media.video_set_marquee_string(vlc.VideoMarqueeOption.Text, content)
================
Text
----------------
创建调用代码
================
Code
----------------
if "__main__" == __name__:
    player = Player("--sub-source=marq")

    player.play("http://hd.yinyuetai.com/uploads/videos/common/"
                                 "22970150925A6BB75E20D95798D129EE.flv?sc\u003d17d6a907580e9892"
                                 "\u0026br\u003d1103\u0026vid\u003d2400382\u0026aid\u003d32"
                                 "\u0026area\u003dML\u0026vst\u003d0")
    player.set_marquee()
    player.update_text("%Y-%m-%d %H:%M:%S")

    while True:
        pass
================
Text
----------------
video_set_marquee_string函数不仅支持直接传入字符串，还支持"%Y-%m-%d %H:%M:%S"这种时间格式，运行上述代码后，会在屏幕下方显示当前时间，且每一秒刷新一次。
关于文本的一些属性设置
上面的示例仅仅显示了一个固定的时间字符串，下面我们看一下如何显示连续的字幕
================
Code
----------------
if "__main__" == __name__:
    player = Player("--sub-source=marq")

    player.play("http://hd.yinyuetai.com/uploads/videos/common/"
                                 "22970150925A6BB75E20D95798D129EE.flv?sc\u003d17d6a907580e9892"
                                 "\u0026br\u003d1103\u0026vid\u003d2400382\u0026aid\u003d32"
                                 "\u0026area\u003dML\u0026vst\u003d0")
    player.set_marquee()

    i = 0
    while True:
        # 字幕每2秒刷新一条
        time.sleep(2)
        player.update_text("我是字幕君 "+str(i))
        i += 1
================
Header
----------------
VLC的选项参数设置
================
Code
----------------
'''
        args:设置 options
    '''

    def __init__(self, *args):
        if args:
            instance = vlc.Instance(*args)
            self.media = instance.media_player_new()
        else:
            self.media = vlc.MediaPlayer()
================
Text
----------------
我们在封装时，特意预留了选项参数的设置，上面添加字幕时，用到了"--sub-source=marq"参数，实际上VLC有非常多的参数，关于各种参数的详细介绍，可以查看 官方资料 如果看英文太累，这里还有一份 中文版参数详解
================
Header
----------------
音频可视化
================
Text
----------------
在VLC众多参数中，有一个非常有用的功能，那就是显示音频的可视化。这里我们以频谱为例
================
Code
----------------
if "__main__" == __name__:
    player = Player("--audio-visual=visual", "--effect-list=spectrum", "--effect-fft-window=flattop")

    player.play("https://api.mlwei.com/music/api/wy/?key=523077333&cache=1&type=url&id=566442496")

    while True:
        pass
================
Text
----------------
--effect-list=<字符串>
当前可用的效果包括: dummy、scope、spectrum（频谱）、spectrometer（频谱仪）与vuMeter
--effect-fft-window=
可选的值{none,hann,flattop,blackmanharris,kaiser}
================
Header
----------------
在Tkinter中嵌入视频
================
Text
----------------
上面的测试代码都是在命令行执行的，虽然运行后启动了一个窗口渲染视频，但是我们无法进行暂停、快进、退出、设置音量等操作，这是因为我们没有写GUI程序，而tkinter作为Python犀利的图形程序库，可以帮助我们快速构建一个界面程序。
完整示例代码如下
================
Code
----------------
import os, platform

# 设置VLC库路径，需在import vlc之前
os.environ['PYTHON_VLC_MODULE_PATH'] = "./vlc-3.0.6"

import vlc

class Player:
    '''
        args:设置 options
    '''

    def __init__(self, *args):
        if args:
            instance = vlc.Instance(*args)
            self.media = instance.media_player_new()
        else:
            self.media = vlc.MediaPlayer()

    # 设置待播放的url地址或本地文件路径，每次调用都会重新加载资源
    def set_uri(self, uri):
        self.media.set_mrl(uri)

    # 播放 成功返回0，失败返回-1
    def play(self, path=None):
        if path:
            self.set_uri(path)
            return self.media.play()
        else:
            return self.media.play()

    # 暂停
    def pause(self):
        self.media.pause()

    # 恢复
    def resume(self):
        self.media.set_pause(0)

    # 停止
    def stop(self):
        self.media.stop()

    # 释放资源
    def release(self):
        return self.media.release()

    # 是否正在播放
    def is_playing(self):
        return self.media.is_playing()

    # 已播放时间，返回毫秒值
    def get_time(self):
        return self.media.get_time()

    # 拖动指定的毫秒值处播放。成功返回0，失败返回-1 (需要注意，只有当前多媒体格式或流媒体协议支持才会生效)
    def set_time(self, ms):
        return self.media.get_time()

    # 音视频总长度，返回毫秒值
    def get_length(self):
        return self.media.get_length()

    # 获取当前音量（0~100）
    def get_volume(self):
        return self.media.audio_get_volume()

    # 设置音量（0~100）
    def set_volume(self, volume):
        return self.media.audio_set_volume(volume)

    # 返回当前状态：正在播放；暂停中；其他
    def get_state(self):
        state = self.media.get_state()
        if state == vlc.State.Playing:
            return 1
        elif state == vlc.State.Paused:
            return 0
        else:
            return -1

    # 当前播放进度情况。返回0.0~1.0之间的浮点数
    def get_position(self):
        return self.media.get_position()

    # 拖动当前进度，传入0.0~1.0之间的浮点数(需要注意，只有当前多媒体格式或流媒体协议支持才会生效)
    def set_position(self, float_val):
        return self.media.set_position(float_val)

    # 获取当前文件播放速率
    def get_rate(self):
        return self.media.get_rate()

    # 设置播放速率（如：1.2，表示加速1.2倍播放）
    def set_rate(self, rate):
        return self.media.set_rate(rate)

    # 设置宽高比率（如"16:9","4:3"）
    def set_ratio(self, ratio):
        self.media.video_set_scale(0)  # 必须设置为0，否则无法修改屏幕宽高
        self.media.video_set_aspect_ratio(ratio)

    # 设置窗口句柄
    def set_window(self, wm_id):
        if platform.system() == 'Windows':
            self.media.set_hwnd(wm_id)
        else:
            self.media.set_xwindow(wm_id)

    # 注册监听器
    def add_callback(self, event_type, callback):
        self.media.event_manager().event_attach(event_type, callback)

    # 移除监听器
    def remove_callback(self, event_type, callback):
        self.media.event_manager().event_detach(event_type, callback)


import tkinter as tk

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.player = Player()
        self.title("流媒体播放器")
        self.create_video_view()
        self.create_control_view()

    def create_video_view(self):
        self._canvas = tk.Canvas(self, bg="black")
        self._canvas.pack()
        self.player.set_window(self._canvas.winfo_id())

    def create_control_view(self):
        frame = tk.Frame(self)
        tk.Button(frame, text="播放", command=lambda: self.click(0)).pack(side=tk.LEFT, padx=5)
        tk.Button(frame, text="暂停", command=lambda: self.click(1)).pack(side=tk.LEFT)
        tk.Button(frame, text="停止", command=lambda: self.click(2)).pack(side=tk.LEFT, padx=5)
        frame.pack()

    def click(self, action):
        if action == 0:
            if self.player.get_state() == 0:
                self.player.resume()
            elif self.player.get_state() == 1:
                pass  # 播放新资源
            else:
                self.player.play("http://hd.yinyuetai.com/uploads/videos/common/"
                                 "22970150925A6BB75E20D95798D129EE.flv?sc\u003d17d6a907580e9892"
                                 "\u0026br\u003d1103\u0026vid\u003d2400382\u0026aid\u003d32"
                                 "\u0026area\u003dML\u0026vst\u003d0")
        elif action == 1:
            if self.player.get_state() == 1:
                self.player.pause()
        else:
            self.player.stop()

if "__main__" == __name__:
    app = App()
    app.mainloop()
================
Text
----------------
最后说一点，如果我们在创建Player时，指定音频可视化参数，如下,则当播放音频时，self._canvas中将显示音频可视化频谱。
================
Code
----------------
player = Player("--audio-visual=visual", 
"--effect-list=spectrum", "--effect-fft-window=flattop")
================
Header
----------------
跨平台
================
Text
----------------
如果我们想用Python开发跨平台的播放器，在Linux系统中，不推荐集成VLC二进制文件，我们可以有两种思路，Ubuntu中，我们可以通过调用命令在线安装vlc
================
Code
----------------
sudo apt-get install vlc
================
Text
----------------
另一种思路则是集成VLC源码，调用系统的编译命令进行编译。通常Linux平台都会带有gcc编译器和make构建工具。该方案同样适用于Mac os平台。
================
Header
----------------
音频播放器项目
================
Text
----------------
博主基于VLC编写的简单音频播放器，可支持本地音频文件以及在线流媒体播放，在线接口使用网易云音乐。传送门
对tkinter的界面程序开发感兴趣的朋友，可观看博主的 tkinter从入门到实战视频 通过该播放器项目对tkinter界面编程进行详细讲解，突出tkinter使用中的各种坑与细节。
关注我的公众号：编程之路从0到1
================
Title
----------------
Python tkinter 自定义tabview
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/89150105
================
Stars
----------------
36
================
Text
----------------
对Tkinter学习感兴趣，推荐观看博主的 tkinter 详解视频教程
ttk中虽然添加了Notebook，但其功能过于简单，无法支持双击创建选项卡，删除选项卡等功能，于是自定义了tabview，有需要的朋友，可以参考在tkinter中自定义view的方法，自定义自己的view
源码地址 如果觉得有用，请不要吝啬一颗小星星
示例
================
Code
----------------
import tkinter as tk
from tkinter import messagebox
from tabview import TabView

# 在body中生成widget的函数，返回的widget将被添加到tabview的body中
def create_body():
    global body
    return tk.Label(body, text="this is body")

# 点击选项卡时的回调
def select(index):
    print("current selected -->", index)

# 删除选项卡时的回调，如果返回False将不会删除
def remove(index):
    print("remove tab -->", index)
    if messagebox.askokcancel("标题", "确定要关闭该选项卡吗？"):
        return True
    else:
        return False

# ----------------------- 使用示例 ----------------------------
root = tk.Tk()
root.geometry("640x300")

tab_view = TabView(root, generate_body=create_body,
                   select_listen=select, remove_listen=remove)

body = tab_view.body

label_1 = tk.Label(tab_view.body, text="this is tab1")
label_2 = tk.Label(tab_view.body, text="this is tab2")

# 第一个参数是向body中添加的widget, 第二个参数是tab标题
tab_view.add_tab(label_1, "tabs1")
tab_view.add_tab(label_2, "tabs2")

# TabView需要向x、y方向填充，且expand应设置为yes
tab_view.pack(fill="both", expand='yes', pady=2)

root.mainloop()
================
Header
----------------
关注我的公众号：编程之路从0到1
================
Title
----------------
静态链表
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/algzjh/article/details/52893224
================
Stars
----------------
0
================
Text
----------------
使用游标（cursor）来模拟指针，由程序员自己编写“分配结点”和“回收结点”的过程。
每个节点应含有两个域：element域和next域。
next域是游标指示器，指示其后继结点在结构数组中的相对位置（即数组的下标），数组的第0个分量可以设计成表的头结点。
================
Code
----------------
//文件 CursorList.h，静态链表的定义
#ifndef CursorList_
#define CursorList_

template <class Object>
class CursorListItr;

template <class Object>
class CursorList
{
public:
    CursorList();
    CursorList(const CursorList & rhs);
    ~CursorList();

    bool isEmpty() const;
    void makeEmpty();
    CursorListItr<Object> first() const;
    void insert(const Object & x, const CursorListItr<Object> & p);
    CursorListItr<Object> find(const Object & x) const;
    CursorListItr<Object> findPrevious(const Object & x) const;
    void remove(const Object & x);
public:
    struct CursorNode
    {
        CursorNode() : next(0) {}
    private:
        CursorNode(const Object & theElement, int n):element(theElement), next(n) {}
        Object element;
        int next;
        friend class CursorList<Object>;
        friend class CursorListItr<Object>;
    };
private:
    int header;

    static vector<CursorNode> cursorSpace;

    static void initializeCursorSpace();
    static int alloc();
    static void free(int p);

    friend class CursorListItr<Object>;
};

//CursorListItr类：维护 "当前位置"
template <class Object>
class CursorListItr
{
public:
    CursorListItr() : current(0) {}
    bool isPastEnd() const
    { return current == 0; }
    void advance()
    {
        if (!isPastEnd())
            current = CursorList<Object>::cursorSpace[current].next;
    }
    const Object & retrieve() const
    {
        if (isPastEnd()) throw BadIterator();
        return CursorList<Object>::cursorSpace[current].element;
    }
private:
    int current;       //当前位置
    friend class CursorList<Object>;

    CursorListItr(int theNode) : current(theNode) { }
};
#endif // CursorList_
//静态链表的主要实现如下面代码所示
#include "CursorList.h"

//初始化
template <class Object>
void CursorList<Object>::initializeCursorSpace()
{
    static int cursorSpaceIsInitialized = false;

    if (!cursorSpaceIsInitialized)
    {
        cursorSpace.resize(100);
        for (int i = 0; i < cursorSpace.size(); i++)
            cursorSpace[i].next = i + 1;
        cursorSpace[cursorSpace.size() - 1].next = 0;
        cursorSpaceIsInitialized = true;
    }
}

//分配结点
template <class Object>
int CursorList<Object>::alloc()
{
    int p = cursorSpace[0].next;
    cursorSpace[0].next = cursorSpace[p].next;
    return p;
}

//释放结点
template <class Object>
void CursorList<Object>::free(int p)
{
    cursorSpace[p].next = cursorSpace[0].next;
    cursorSpace[0].next = p;
}

//构造静态表
template <class Object>
CursorList<Object>::CursorList()
{
    initializeCursorSpace();
    header = alloc();
    cursorSpace[header].next = 0;
}

//逻辑判空
template <class Object>
bool CursorList<Object>::isEmpty() const
{
    return cursorSpace[header].next == 0;
}

//在p所指向单元后插入x
template <class Object>
void CursorList<Object>::insert(const Object & x, const CursorListItr<Object> & p)
{
    if (p.current != 0)
    {
        int pos = p.current;
        int tmp = alloc();

        cursorSpace[tmp] = CursorNode(x, cursorSpace[pos].next);
        cursorSpace[pos].next = tmp;
    }
}

//返回值为x的第一个结点
template <class Object>
CursorListItr<Object> CursorList<Object>::find(const Object & x) const
{
    int itr = cursorSpace[header].next;
    while (itr != 0 && cursorSpace[itr].element != x)
        itr = cursorSpace[itr].next;
    return CursorListItr<Object>(itr);
}

//返回值为x的第一个结点的前驱
template <class Object>
CursorListItr<Object> CursorList<Object>::findPrevious(const Object & x) const
{
    int itr = header;
    while (cursorSpace[itr].next != 0&&cursorSpace[cursorSpace[itr].next].element != x)
        itr = cursorSpace[itr].next;
    return CursorListItr<Object>(itr);
}

//删除第一个值为 x的元素
template <class Object>
void CursorList<Object>::remove(const Object & x)
{
    CursorListItr<Object> p = findPrevious(x);  //查找前驱
    int pos = p.current;

    if (cursorSpace[pos].next != 0)
    {
        int tmp = cursorSpace[pos].next;
        cursorSpace[pos].next = cursorSpace[tmp].next;
        free (tmp);
    }
}
================
Title
----------------
POJ1258
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/algzjh/article/details/52305240
================
Stars
----------------
1
================
Text
----------------
Description
Input
Output
Sample Input
Sample Output
================
Code
----------------
/*
Primq求MST
耗费矩阵cost[][],标号从0开始，0~n-1
返回最小生成树的权值，返回-1表示原图不连通
*/

#include<iostream>
#include<string.h>
#include<cstdio>
using namespace std;

const int INF=0x3f3f3f3f;
const int MAXN=505;
int cost[MAXN][MAXN];
bool vis[MAXN];
int lowc[MAXN];

int Prim(int cost[][MAXN],int n)//点是0~n-1
{
    int ans=0;
    memset(vis,false,sizeof(vis));
    vis[0]=true;
    for(int i=1;i<n;i++)
        lowc[i]=cost[0][i];
    for(int i=1;i<n;i++)
    {
        int minc=INF;
        int p=-1;
        for(int j=0;j<n;j++)
        {
            if(!vis[j]&&minc>lowc[j])
            {
                minc=lowc[j];
                p=j;
            }
        }
        if(minc==INF)
            return -1;//原图不连通
        ans+=minc;
        vis[p]=true;
        for(int j=0;j<n;j++)
        {
            if(!vis[j]&&lowc[j]>cost[p][j])
                lowc[j]=cost[p][j];
        }
    }
    return ans;
}

int main()
{
    int n;
    while(cin>>n)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                cin>>cost[i][j];
            }
        }
        int res=Prim(cost,n);
        cout<<res<<endl;
    }
    return 0;
}
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;

#define N 10005
#define INF 0x3f3f3f3f
int a[N][N];
int ans;
bool vis[N];
int dis[N],n;

bool Prim()
{
    memset(vis,0,sizeof(vis));
    memset(dis,INF,sizeof(dis));
    ans=0;
    dis[1]=0;
    for(int i=1;i<=n;i++)
    {
        int tmp=INF;
        int k=0;
        for(int j=1;j<=n;j++)
        {
            if(!vis[j]&&dis[j]<tmp)
            {
                tmp=dis[j];
                k=j;
            }
        }
        if(tmp==INF)
        {
            return false;
        }
        vis[k]=true;
        ans+=tmp;
        for(int j=1;j<=n;j++)
        {
            if(!vis[j]&&dis[j]>a[k][j])
            {
                dis[j]=a[k][j];
            }
        }
    }
    return true;
}

int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        ans=0;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                scanf("%d",&a[i][j]);
            }
        }
        Prim();
        cout<<ans<<endl;
    }
    return 0;
}
================
Title
----------------
IEEE VIS Citations
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/algzjh/article/details/72972843
================
Stars
----------------
0
================
Header
----------------
IEEE VIS Citations
================
Title
----------------
Flutter 的键值存储数据库
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/126219092
================
Stars
----------------
0
================
Header
----------------
Flutter 键值存储数据库
================
Text
----------------
键值存储是开发中十分常见的需求，在Flutter开发中，一般使用 shared_preferences 插件来实现。shared_preferences 本质上就是将键值对保存到一个XML文件中进行持久化。而shared_preferences 实际上存在一定缺陷，譬如其性能较差，不适合处理大量数据，不能创建新的XML文件，所有数据存在同一个文件中。除此外，还有其他一些持久化方案，如SQLite、Hive等。SQLite是关系型数据库，使用起来相对繁琐；而Hive是用Dart实现的一个轻量级键值对数据库，它使用简单，但同样性能较差，而且在储存大量数据时，更加耗费内存，因为它是一次性将所有数据读取到内存中，这在移动端不是很可取。当然，如果你只是用来存储几个简单的配置项数据，那也够用了。
================
Header
----------------
unqlite
================
Text
----------------
以上概述了一下Flutter的键值持久化方案，那么接下来就隆重介绍一下本文推荐的Flutter键值存储方案——一个轻量级嵌入式nosql数据库unqlite！
unqlite是一个嵌入式的数据库，它实现了一个独立的、无服务器、零配置、事务性的nosql数据库引擎。它是一个文档存储数据库，类似于MongoDB, Redis, CouchDB等，同时也是一个标准的key/value存储数据库，类似于BerkeleyDB, LevelDB, 等。
简单概括，unqlite是一个标准C语言实现的轻量级、高性能nosql数据库，经过编译后，它只有几百KB大小，可以嵌入到我们的App中，它与SQLite数据库类似，区别在于一个是基于SQL的关系型数据库，一个是NoSql数据库。
================
Header
----------------
unqlite_flutter
================
Text
----------------
既然unqlite是一个C语言编写的数据库，那么Flutter开发如何使用它呢？
随着Dart版本的不断迭代，Dart语言的FFI接口逐渐成熟，FFI类似于Java的JNI，赋予了Dart语言直接调用C语言的能力。有了这种能力，那么基于C/C++开发的优秀的高性能的库，都可以用于Flutter开发中，可以说是C/C++生态为我所用！想学习Flutter的FFI开发，可以参考博主的B站视频 Dart FFI开发入门 以及 程序员的C
当然，这里我已经完成了Dart FFI调用的封装，可以直接依赖我开发好的插件库——unqlite_flutter
目前已完成的功能：
================
Header
----------------
快速上手
================
Header
----------------
简单键值对存储
================
Text
----------------
添加依赖：
================
Code
----------------
unqlite: ^0.0.3
  unqlite_flutter: ^0.0.3
================
Text
----------------
示例代码：
================
Code
----------------
// 创建或打开一个数据库
UnQLite db = UnQLite.open("${appDocDir.path}/test.db");

// 保存键值对
db.store("name", "Alex");
db.store("age", 18);
db.store(19, "haha");

// 通过指定泛型获取值
debugPrint(db.fetch<String>("name"));
debugPrint('${db.fetch<int>("age")}');
debugPrint(db.fetch<String>(19));

// 另一种获取值的方法
db.fetchCallback<int>("age", (val) {
    debugPrint('age=$val');
});
================
Text
----------------
当然，还有另一种获取数据的方式，可能比fetch更快：
================
Code
----------------
var cursor = db.cursor();
cursor.seek('name');
debugPrint('=> ${cursor.key} => ${cursor.value}');
================
Text
----------------
你还可以使用事务。在一个事务中，如果发生异常，你可以回滚所有操作：
================
Code
----------------
var trans = db.transaction().begin();
    try {
      for (var i = 0; i < 100000; i++) {
        if (i == 10) {
          // 这里我们抛出一个异常
          throw Exception('test');
        }
        db.store("transaction_$i", "here is a transaction_$i");
      }
      trans.commit();
    } catch (e) {
      // 处理异常，手动回滚事务
      trans.rollback();
    }
================
Text
----------------
以上示例中，我们保存十万个数据，一旦中间发生了什么异常，我们执行回滚操作，则前面所有的保存的数据将被取消。
你还可以使用迭代器来进行遍历:
================
Code
----------------
for (var entry in db.cursor()) {
  var content = '${entry.key} => ${entry.value}';
  debugPrint(content);
}
================
Header
----------------
JSON
================
Text
----------------
处理JSON文档
================
Code
----------------
UnQLite db = UnQLite.open("${appDocDir.path}/test2.db");
    var users = db.collection("users");
	// Create a collection
    users.create();

	// 保存JSON
    users.store(jsonDecode('''
{
        "title": "test json string",
        "author": [
                "arcticfox1919"
        ],
        "year": 2022,
        "like": "flutter"
}
    '''));

    users.store({'name': 'Mickey', 'age': 17});
    users.store([
      {'name': 'Alice', 'age': 18},
      {'name': 'Bruce', 'age': 19},
      {'name': 'Charlie', 'age': 20},
    ]);

	// 获取全部数据
    print(users.all());
    // print(users.fetch(0));
    // print(users.fetch(1));
    // print(users.fetch(2));
    // print(users.errorLog());

    print(users.creationDate());
    print(users.len());
    print(users.fetchCurrent());

    // 删除全部
    users.drop();
    db.close();
================
Header
----------------
为什么你应该使用unqlite_flutter？
================
Text
----------------
它有什么缺点？ 因为使用了dart ffi，所以不能支持Flutter web。
下面是一些性能测试数据，这里没有列出内存占用的百分比，但可以肯定 unqlite 比Hive 使用了更少的内存：
UnQLite:
================
Code
----------------
UnQLite init:1 ms
write 100,000 entries :611 ms
fetch 100,000 entries :370 ms
seek  100,000 entries :215 ms
iterate 100,000 entries :225 ms
transaction rollback :39 ms
================
Text
----------------
Hive:
================
Code
----------------
Hive init:48 ms
put 100,000 entries :807 ms
get 100,000 entries :290 ms
================
Text
----------------
这是用于测试的代码，两者都在同一部真机上以profile模式运行：
================
Code
----------------
testUnQLite() async {
    var appDocDir = await getApplicationDocumentsDirectory();
    final start = DateTime.now().millisecondsSinceEpoch;
    UnQLite db = UnQLite.open("${appDocDir.path}/test.db");
    final t1 = DateTime.now().millisecondsSinceEpoch;

    for (var i = 0; i < 100000; i++) {
      db.store("my_key_$i", "Here is a value for testing—$i");
    }

    final t2 = DateTime.now().millisecondsSinceEpoch;
    for (var i = 0; i < 100000; i++) {
      var r = db.fetch<String>("my_key_$i");
      // debugPrint("fetch :$r");
    }
    final t3 = DateTime.now().millisecondsSinceEpoch;
    
    var cursor = db.cursor();
    for (var i = 0; i < 100000; i++) {
      cursor.seek('my_key_$i');
      // debugPrint('=> ${cursor.key} => ${cursor.value}');
    }
    final t4 = DateTime.now().millisecondsSinceEpoch;

    var count = 0;
    for (var entry in db.cursor()) {
      count++;
      var content = '${entry.key} => ${entry.value}';
      // debugPrint(content);
    }
    print('count => $count');
    final t5 = DateTime.now().millisecondsSinceEpoch;

    var trans = db.transaction().begin();
    try {
      for (var i = 0; i < 100000; i++) {
        if (i == 10) {
          throw Exception('test');
        }
        db.store("transaction_$i", "here is a transaction_$i");
      }
      trans.commit();
    } catch (e) {
      trans.rollback();
    }
    final t6 = DateTime.now().millisecondsSinceEpoch;

    debugPrint("UnQLite init:${t1-start} ms");
    debugPrint("write 100,000 entries :${t2-t1} ms");
    debugPrint("fetch 100,000 entries :${t3-t2} ms");
    debugPrint("seek  100,000 entries :${t4-t3} ms");
    debugPrint("iterate 100,000 entries :${t5-t4} ms");
    debugPrint("transaction rollback :${t6-t5} ms");
    db.close();
  }

  testHive() async {
    var appDocDir = await getApplicationDocumentsDirectory();
    var path = appDocDir.path;
    final start = DateTime.now().millisecondsSinceEpoch;
    Hive.init(path);
    var box = await Hive.openBox('testBox');

    final t1 = DateTime.now().millisecondsSinceEpoch;

    for (var i = 0; i < 100000; i++) {
      box.put("my_key_$i", "here is a transaction_$i");
    }

    final t2 = DateTime.now().millisecondsSinceEpoch;

    for (var i = 0; i < 100000; i++) {
      var name = box.get('my_key_$i');
    }

    final t3 = DateTime.now().millisecondsSinceEpoch;

    box.close();
    debugPrint("Hive init:${t1-start} ms");
    debugPrint("put 100,000 entries :${t2-t1} ms");
    debugPrint("get 100,000 entries :${t3-t2} ms");
  }
================
Title
----------------
Integrating Prior Knowledge in Mixed Initiative Social Network Clustering
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/algzjh/article/details/109713288
================
Stars
----------------
0
================
Text
----------------
论文传送门
我们提出了一种新的范式——称为PK聚类——来帮助社会科学家在社会网络中创建有意义的聚类。存在许多聚类算法，但大多数社会科学家发现它们难以理解，并且工具没有提供任何指导来选择算法，或者考虑到科学家的先验知识来评估结果。我们的工作引入了一个新的集群范例和一个可视化分析用户界面来解决这个问题。它基于以下过程:1)将科学家的先验知识捕获为一组不完整的聚类，2)运行多个聚类算法(类似于聚类集成方法)，3)通过每个算法与先验知识的匹配程度来可视化所有排序和总结的算法的结果，5)评估用户选择的算法之间的一致性，6)允许用户查看细节并迭代更新获得的知识。我们用一个最初的功能原型来描述我们的范例，然后提供两个使用的例子和来自社会科学家的早期反馈。我们相信，我们的聚类范例提供了一种新颖的建设性方法来迭代地构建知识，同时避免被经常随机选择的黑盒聚类算法的结果过度影响。
传统聚类不令人满意，主要原因有：
本文的贡献：
================
Title
----------------
开发一个APP多少钱？
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/128050095
================
Stars
----------------
0
================
Header
----------------
开发一个APP多少钱？
================
Text
----------------
开发一个APP要多少钱？相信不光是客户有这个疑问，就算是一般的程序员也想知道答案。很多程序员想在业余时间接外包挣外快，但是他们常常不知道该如何定价，如何有说服力的要价。这是因为没有一套好的计算APP开发成本的方法。由于国内没有公开的数据，而且大家对于报价都喜欢藏着掖着，这里我们就整理了国外一些软件外包平台的资料，帮助大家对Flutter APP开发成本有一个直观而立体的认识。（注意，这里是以美元单位计算，请不要直接转换为RMB，应当根据消费力水平来衡量）
跨平台项目正在慢慢取代原生应用程序的开发。跨平台的方法更省时，也更节省成本。最近，原生应用程序的主要优势是其性能。但随着新的跨平台框架给开发者带来更多的力量，这不再是它们的强项。
Flutter就是其中之一。这个框架在2017年发布，并成为跨平台社区中最受推崇的框架之一。Statista称，Flutter是2021年十大最受欢迎的框架之一，并在最受欢迎的跨平台框架中排名第一。对于这样一项新技术来说，这是一个相当不错的结果。它的高需求使我们可以定义软件建设的大致成本。
Flutter应用程序的开发成本根据项目定义的工作范围而变化：
================
Code
----------------
$40,000 - $60,000
$60,000 – $120,000
$120,000 – $200,000+
================
Text
----------------
有一些决定性的因素来回答Flutter应用开发的成本是多少。
在这篇文章中，我们将讨论不同行业的Flutter应用开发成本，找出如何计算精确的价格，以及如何利用这个框架削减项目开支。
================
Header
----------------
Flutter应用的平均开发成本
================
Text
----------------
应用程序的开发成本是一个复杂的数字，取决于各种因素 ——功能的复杂性，开发人员的位置，支持的平台，等等。如果不进行研究和了解所有的要求，就不可能得出项目的价格。
不过，你还是可以看看按项目复杂程度分类的估算：
================
Header
----------------
影响价格的因素
================
Text
----------------
为了明确 Flutter 应用开发成本的所有组成部分，我们将挑选出每个因素并分析其对价格的影响。
原生应用开发 vs. Flutter
当我们估算一个原生项目时，我们要考虑到两个平台的开发时间。Flutter是一个跨平台的框架，可以让开发者为Android和iOS编写同一个代码库。这一特点使开发时间减半，使Flutter应用程序的开发成本比原生的低。
Flutter 的非凡之处在于它优化了代码并且没有性能问题。Flutter在所有设备上都能提供稳定的接近 60 FPS，如果设备支持，甚至可以提供120 FPS。
然而，Flutter也有一些缺点。如果你的项目需要Wear OS版本或智能电视应用，就会面临一些麻烦。从技术上讲，你可以为这些平台建立一个Flutter应用程序。但是，Flutter的很多开发功能并不被Wear OS所支持。在安卓电视的情况下，必须从头开始建立控制逻辑。原因是安卓电视只读取遥控器的输入，而Flutter则适用于触摸屏和鼠标移动。这一事实会减慢开发进程，给开发者带来麻烦，并增加Flutter应用的开发成本。
这就是为什么如果你的目标是特定的平台，最好去做原生开发。
功能的复杂性
功能是应用程序的主要组成部分。也是影响Flutter应用程序开发成本的主要因素。简单的功能（如登录）需要最少的工作量，而视频通话的集成可能需要长达 2-3 周的开发时间。
让我们想象一下，要建立一个类似 Instagram 的应用程序。照片上传功能需要大约13小时的开发时间。以每小时50美元的平均费率计算，这将花费650美元。然而，要建立用于照片编辑的过滤器，开发团队将不得不花费30至120小时，这取决于它们的类型和数量。一家软件开发公司将为这个功能收取1500-6000美元。
Flutter应用开发中最昂贵的功能
================
Code
----------------
$9,700
$9,400
$3,500
================
Text
----------------
开发商的位置和所选择的雇用方式
影响总成本的另一个方面是你在雇用项目专家时选择的就业方式：
自由职业者
由于有机会减少开发费用，这种选择被广泛采用。然而，就Flutter应用的开发而言，无法保证自由职业者的能力和质量。此外，在支持、维护和更新服务方面，这样的专家也没有优势，因为他们可能会转到另一个项目，从而无法建立长期的合作伙伴关系。
内部团队
在这种情况下，你要负责项目开发管理，以及搜索和检查潜在雇主的经验和知识。此外，内部团队的聚集需要一排额外的费用，如购买硬件，租用办公室，病假，工资，等等。因此，这些条件大大增加了总成本。
外包公司
项目外包指的是已经组建的专家团队，具有成熟深入的资质，接手所有的创作过程。这种选择是一种节省开发投资和避免影响产品质量的好方法。除了这个事实之外，这里还有一些你将通过外包获得的好处。
成本的灵活性。全球市场提供了很多准备以合理价格提供服务的外包软件开发公司。中欧已经成为实现这一目标的顶级地区，许多企业已经从来自该地的优秀开发人员的一流表现中受益。
可扩展性。可以根据您的要求调整开发流程：此类公司的团队包括所有类型的开发人员，将在需要他们的能力时参与创建过程。此外，如果有必要的话，这也是加快项目完成的绝佳方式。外包提供了多种合作模式。 从专门的团队到工作人员的增援
更快的产品交付。有了外包，就不需要在招聘上花费时间。你可以调整项目创建速度，例如，让更多的专家参与进来。因此，进入市场的时间缩短了，支出也减少了。只为已完成的工作付费。
庞大的人才库。IT外包包括大量具有丰富专业知识和经验的技术专家。外包商为企业提供灵活的招聘机会。你可以在全球范围大量的的软件架构师中选择。
可应用的技术非常多样化。根据你的项目要求，你可以从这些公司中选择一个具有相关专业知识的专家。
除了雇佣选择，开发团队的位置可能会对Flutter应用程序的开发成本产生很大的影响。在不同地区，开发人员有不同的价格。在美国，开发人员的平均费率是60美元/小时，而在爱沙尼亚，只有37美元/小时。
在下面的表格中，可以找到开发人员的每小时费率，并将它们进行比较。
Flutter开发人员在不同地区的费率：
================
Code
----------------
$75 - $120
$30 - $50
$70 - $90
$30 - $50
$25 - $40
$41 - $70
$20 - $49
================
Header
----------------
如何计算 Flutter 应用开发成本
================
Text
----------------
正如前面提到的，功能对Flutter应用开发成本的影响最大。Flutter 适用于不包含原生功能的项目。但是当涉及到地图、流媒体、AR和后台进程时，开发人员必须为iOS和Android单独构建这些功能，然后再与Flutter结合。
让我们回到例子上。如果是原生开发，你将需要大约60-130个小时在你的应用程序中实现AR过滤器。Flutter开发将需要约80-150小时，因为AR是一个原生功能。考虑到50美元/小时的费率，我们应该把它乘以开发时间。这个公式可以用来计算出最终的Flutter应用开发成本。
除了这个公式外，还有一件事在初始阶段很重要。
================
Header
----------------
发现阶段
================
Text
----------------
一个糟糕的发现阶段可能导致整个项目的崩溃。但为什么这个阶段如此重要？在发现阶段，业务分析人员和项目经理与你举行会议，找出可能的风险，并提出消除这些风险的解决方案
================
Header
----------------
粗略估算
================
Text
----------------
粗略估算的精确度从75%到25%不等。这个评估包括在客户和软件团队合作的初级阶段。它也有助于双方决定是否成为合作伙伴。粗略估算的主要目的是计算完成项目所需的最短和最长时间以及大致的总成本，以便客户知道在开发流程中需要多少投资。此外，这个估算包括整个创建过程，分为几个阶段。这个文件不应该被认为是有固定条款和条件的文件。它是为客户准备的，只是为了通知他们。
一个粗略的估算包括：
主要部分包含准备工作。它们在不同的项目中都是一样的，包括产品描述、数据库设置、REST架构。该部分所指出的项目不一定一次就能完成。有些工作是在整个项目中完成的。
开发与加密过程有关。这部分包括要实现的功能、屏幕和特性。开发部分包括 "业务逻辑 "和 "UI/UX "要求，以及某部分工作的小时数。
为了更有效地实现功能，需要整合框架和库，并相应减少开发时间和相应的花费。
非开发工作主要与技术写作有关。专家们准备详细的代码文档和准备有关产品创建的其他数据。
建议部分包含了各种改进建议。
当所有的问题都解决后，会进入发现阶段并创建一个项目规范。客户必须积极参与，因为会根据客户提供的数据来建立项目规范。在下一个阶段，客户应当创建他们的应用程序草稿图。这是一个用户界面元素在屏幕上的位置示意图。
然后，开发人员和业务分析师会对客户的Flutter应用开发成本进行详细的估算。有了准确的预算、项目要求和草稿图，就可以签署合同并开始开发阶段。
如你所见，发现阶段是任何项目的关键部分。没有这个阶段，你就无法知道开发所需的价格和时间，因为会有太多的变数。如果在任何阶段出了问题，整个项目的计划就会出问题。这就是为什么客户必须与软件开发公司合作，使他们能够建立客户需要的项目。
================
Header
----------------
额外费用
================
Text
----------------
就像任何其他产品一样，客户的应用程序需要维护和更新，以便在市场上保持成功。这导致了影响Flutter应用程序开发成本的额外费用。
================
Header
----------------
服务器
================
Text
----------------
如果要处理和存储用户产生的数据，就必须考虑到服务器的问题。脆弱的服务器会导致用户方面的低性能和高响应时间。此外，不可靠的服务器和脆弱的保护系统会导致你的用户的个人数据泄露。为了减少风险，团队只信任可靠的供应商，如亚马逊EC2。根据AWS价格计算器，一台8核CPU和32G内存的工作服务器将花费大约1650美元/年。在计算整个Flutter应用程序的开发成本时，请牢记这笔费用。
================
Header
----------------
UI/UX设计
================
Text
----------------
移动应用的导航、排版和配色是UI/UX设计师应该注意的主要问题。他们还应该向你提供你的应用程序的原型。根据你的应用程序的复杂性，设计可能需要40到90多个小时。这一行的费用将使Flutter应用的开发成本提高到2000-4500美元
================
Header
----------------
发布到应用商店
================
Text
----------------
当你已经有了一个成品，你必须在某个地方发布它。Google Play和App Store是应用程序分发的主要平台。然而，这些平台在应用发布前会收取费用：
Google Play 帐号一次收取25美元，可以永久使用
而Apple Store 收取99美元的年费，只要你的APP还想待在应用商店，每年都得花费这笔钱
除此之外，这两个平台对每次产生的应用内购买行为都有30%的分成。如果你通过订阅模式发布你的应用，那你只能得到70%收益。然而，最近Google Play和App Store已经软化了他们的政策。目前，他们对每一个购买了十二个月订阅的账户只收取15%的分成。
================
Header
----------------
应用维护和更新
================
Text
----------------
应用商店排行榜的应用能保持其地位是有原因的。他们通过不断的升级和全新的功能吸引客户。即使你的应用是完美的，但没有更新将导致停滞，用户可能卸载你的应用程序。在完美的构想里，你应该雇用一家开发应用程序的公司。他们从一开始就为你的项目工作。注意，应用程序的维护费用在应用程序的生命周期内会上升。公司通常将Flutter应用开发成本的15-20%纳入应用维护的预算。然而，你的应用程序拥有稳定受众的时间越长，需要投入的更新资金就越多。在一定时间内，你花在更新上的钱比花在实际开发上的钱多，这并不奇怪。尽管如此，但是你的应用产生的收入多于损失，所以这是一项值得的投资。不幸的是，随着新的功能发布可能出现新的错误和漏洞。你不能对这个问题视而不见，因为它使用户体验变差，并为欺诈者提供了新的漏洞。有一些软件开发公司会提供发布后的支持，包括开发新功能、测试和修复错误。
================
Header
----------------
按类型划分的开发成本
================
Text
----------------
由于你已经知道影响价格的主要和次要因素，现在是时候对不同应用程序的Flutter开发成本进行概述了。这里估算了来自不同行业和不同复杂程度的几个现有应用程序的开发成本。
分别是：
================
Header
----------------
Flutter 应用程序开发成本：交通运输
================
Text
----------------
示例：BlaBlaCar
功能实现的大概时间：438 小时
大概费用：21,900 美元
运输应用程序需要用户档案、司机和乘客的角色、支付网关和GPS支持。请注意，如果你使用Flutter来构建地理定位等本地功能，整个项目的开发时间可能会增加。
请注意，下面的估算不包括代码文档、框架集成、项目管理等方面的时间。
下面是一个类似BlaBlaCar的应用程序的基本功能的粗略估计，基于Flutter的交通应用开发成本：
================
Code
----------------
$1400
$1350
$1000
$3850
$2000
$4000
$2100
$1300
$5150
================
Header
----------------
Flutter应用程序开发成本：流媒体
================
Text
----------------
例子: Twitch, Periscope, YouTube Live
功能实现的大概时间: 600小时
大概的成本: $30,000
流媒体应用程序是一个复杂的软件。它要求开发团队使用流媒体协议（这不是Flutter的强项），开发与观众沟通的文本聊天，推送通知，使用智能手机的摄像头，等等。其中一些有捐赠系统，与第三方的多种集成，甚至还有付费的表情符号。以下是一个类似Twitch的应用程序的基本功能的粗略估计。
基于Flutter的流媒体应用开发成本：
================
Code
----------------
$1000
$1150
$2150
$1800
$1000
$1650
$6000
$7300
$1750
$3200
$2000
$1000
================
Header
----------------
Flutter应用程序开发成本：消息通信
================
Text
----------------
例子: Facebook Messenger, WhatsApp, Telegram
功能实现的大概时间: 589小时
估计成本: $29,450
消息通信工具的功能乍一看很简单，但详细的分析证明情况恰恰相反。整合各种状态的聊天（打字，在线/离线，阅读），文件传输，语音信息需要大量的时间。如果再加上语音通话和群组聊天，事情会变得更加复杂。
让我们单独列出每个功能及其成本，基于Flutter的消息通信应用开发成本：
================
Code
----------------
$2250
$1350
$7800
$2000
$1750
$2850
$5000
$750
$3800
$1900
================
Title
----------------
Python tkinter入门详解教程
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/89339194
================
Stars
----------------
276
================
Text
----------------
基于tkinter入门资料太少，特录制了这套入门详解课程，希望能帮助初学者快速掌握tkinter的基础知识和实战技巧，对于伸手党和资料收集党，做了一个门槛限制，希望大家理解
网易云课堂 视频课程地址
https://study.163.com/course/courseMain.htm?courseId=1209232809&share=2&shareId=480000001855430
本课程涉及到tkinter的高级控件讲解，ttk自定义主题样式，tkinter自定义控件，tkinter的异步编程，两个实战项目，自制编辑器，自制播放器
课程基本大纲如下 1.概述 2 基础入门 2.1 基本控件 2.2 布局详解 2.3 事件详解 2.4 面向对象范式 3 高级用法 3.1 高级控件学习 3.2 对话框 3.3 现代风格ttk 3.4 扩展包Pmw 3.5 自定义控件 4. 项目实战 4.1 自制编辑器 4.2 自制播放器 5. 打包发布
================
Header
----------------
编辑器项目
================
Text
----------------
编辑器开发文档
================
Header
----------------
网易云音乐播放器
================
Text
----------------
python 流媒体详解
欢迎关注我的公众号：编程之路从0到1
================
Title
----------------
Android 平台的Python——基础篇(一)
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/78571776
================
Stars
----------------
130
================
Text
----------------
Android 平台的Python——基础篇(一) Android 平台的Python——JNI方案（二） Android 平台的Python——CLE方案实现（三） Android 平台的Python——第三方库移植 Android 平台的Python——编译Python解释器 新篇——Android与Python混合编程
前言 (本文以Python3为例，Python3是未来，大家都懂的) Python作为一个功能强大又语法简洁的语言，其应用已无需多言。要想在Android平台运行起Python，也有方案实现，其实质就是在Android系统上搭建Python环境。对此Google已经提供了SL4A(Scripting Layer for Android )方案，支持多种脚本语言，除此之外，还可以使用一个叫QPython的app，可以直接在Android上编写以及运行Python代码。但其实意义不大，写好的Python代码并不是以一个独立的app进程运行的，只不过是在QPython这个应用中运行而已。这两者都不符合我现在要讨论的东西，如题，笔者想要讨论的是如何在Android平台使用Java与Python代码相互调用，换言之，就是如何在Android工程中嵌入一个Python解释器。
首先谈一点，为什么要在Android平台使用Python？Python拥有众多强大的第三方库和框架，在机器学习、大数据处理等诸多方面都有不俗的应用。另外，就语法而言，Python比Java更加简洁，同时又功能强大，既可面向过程亦可面向对象，而不像Java一样，是一种纯粹的面向对象语言，哪怕打印一句话也需要先创建类。Python作为一种脚本语言，可以边解释边执行，而不需编译，另外Python中存在的元类，可以使我们动态的创建类，如此可以在不需要重新编译安装apk的情况下，动态的由远程服务端为Android项目添加功能。我们还可以将Python已有的一些东西移植到Android平台，例如tornado、django等，总之玩法多多。
在Android平台，官方并不支持直接使用Python开发app，基于虚拟机的Java（或kotlin）才是更好的选择，其他语言是无法自如的使用官方Framework提供的api的，尤其是在程序界面的表现上，典型的反例就是kivy。什么是kivy，可自行了解，但要解决Android平台上Java与Python的交互，kivy确实是一个方向，而且是一个醍醐灌顶的方向。kivy实际上已经解决我们需要实现的目的，模仿Android平台上的kivy实现机制即可。但是，kivy使用了大量的Cython技术，而非CPython API接口，需要学习Cython语法，并且在其他一些方面存在一些限制。kivy给我们提供的思路就是借助Java的jni机制，实现Python与Java的交互。即在一个安卓apk工程中包含一个cython.so解释器，通过jni机制调用解释器去解释执行Python代码，通过Java调C，C调Python实现交互。有一点需要说明，Python作为一门胶水语言，Python与C的交互是非常方便的，因此才能实现这一系列调用。
关于该种方案，已有国外网友实践，原理如下
链接地址
除此之外，本博客将通过另外两种方案实现。其中第一种类似上述方案，但集成CPython解释器，非Cython，因此需要掌握如何实现Python与C的交互。
================
Header
----------------
Python与C交互基础
================
Text
----------------
C调用Python
简单使用 流程：
创建一个.c源文件，代码如下，创建一个pytest.py文件，实现一个printTime函数
================
Code
----------------
#include<Python.h>
	int main()
	{
	    Py_Initialize();//初始化Python解析器
	    if (!Py_IsInitialized())
	    {
		    printf("Initialize failed");
		      return -1;
	    }
	    PyRun_SimpleString("print('hello C !')");
	    PyRun_SimpleString("import pytest");
	    PyRun_SimpleString("pytest.printTime()");
	    Py_Finalize();/关闭Python解析器
	    return 0;
	}
================
Text
----------------
注意：除了用PyRun_SimpleString函数直接运行代码，还可以使用PyRun_SimpleFile函数运行一个Python脚本 原型：PyRun_SimpleFile(FILE *fp, const char *filename) ，由于版本差异，使用该方式可能会造成崩溃，推荐另一种替代方式 PyRun_SimpleString(“execfile(“test.py”)”)
调用Python函数 pytest.py
================
Code
----------------
import time

def printTime():
    print('invoke printTime:'+str(time.time()))
    return (1,)#元组只有一个元素时，需在末尾加逗号
================
Text
----------------
C 代码
================
Code
----------------
int main()
{
	PyObject * module_name,*module,*func,*dic;
	char * fun_name = "printTime";//需调用的Python函数名
	PyObject *resultValue;

	Py_Initialize();
	if (!Py_IsInitialized())
	{
		printf("Initialize failed");
		return -1;
	}

	//导入Python 模块并检验
	module_name = Py_BuildValue("s", "pytest");
	module = PyImport_Import(module_name);

	if (!module)
	{
		printf("import test failed!");
		return -1;
	}
	
    //获取模块中的函数列表，是一个函数名和函数地址对应的字典结构
    dic = PyModule_GetDict(module);
	if (!dic)
	{
		printf("failed !\n");
		return -1;
	}

	func = PyDict_GetItemString(dic, fun_name);
	if (!PyCallable_Check(func))
	{
		printf("not find %s\n", fun_name);
		return -1;
	}

	int r;
    //获取Python函数返回值，是一个元组对象
	resultValue = PyObject_CallObject(func, NULL);
	PyArg_ParseTuple(resultValue, "i", &r);
	printf("result :%d\n", r);

	Py_DECREF(module);
    Py_DECREF(dic);
	Py_Finalize();
	return 0;
}
================
Text
----------------
基础API
================
Code
----------------
PyImport_ImportModel
PyImport_ReloadModule
PyImport_GetModuleDict
PyDict_GetItemString
PyDict_SetItemString
PyDict_New
PyObject_GetAttrString
PyObject_SetAttrString
PyObject_CallObject
PyEval_CallObject
PyRun_String
PyRun_File
================
Text
----------------
Py_BuildValue()函数 作用：将C/C++类型类型的数据转变成PyObject*对象。 原型：PyAPI_FUNC(PyObject*) Py_BuildValue(const char *format, ...);
参数解释： format及转换格式，类似与C语言中%d,%f，后面的不定参数对应前面的格式，具体格式如下：
“s”(string) [char *] ：将C字符串转换成Python对象，如果C字符串为空，返回NONE。
“s#”(string) [char *, int] :将C字符串和它的长度转换成Python对象，如果C字符串为空指针，长度忽略，返回NONE。
“z”(string or None) [char *] :作用同"s"。
“z#” (stringor None) [char *, int] :作用同"s#"。
“i”(integer) [int] :将一个C类型的int转换成Python int对象。
“b”(integer) [char] :作用同"i"。
“h”(integer) [short int] ：作用同"i"。
“l”(integer) [long int] :将C类型的long转换成Pyhon中的int对象。
“c”(string of length 1) [char] ：将C类型的char转换成长度为1的Python字符串对象。
“d”(float) [double] :将C类型的double转换成python中的浮点型对象。
“f”(float) [float] :作用同"d"。
“O&”(object) [converter, anything] ：将任何数据类型通过转换函数转换成Python对象，这些数据作为转换函数的参数被调用并且返回一个新的Python对象，如果发生错误返回NULL。
“(items)”(tuple) [matching-items] ：将一系列的C值转换成Python元组。
“[items]”(list) [matching-items] ：将一系列的C值转换成Python列表。
“{items}”(dictionary) [matching-items] ：将一系类的C值转换成Python的字典，每一对连续的C值将转换成一个键值对。
例： 后面为PyObject的返回值
================
Code
----------------
Py_BuildValue("")None

      Py_BuildValue("i",123) 123

      Py_BuildValue("iii",123, 456, 789) (123, 456, 789)

      Py_BuildValue("s","hello") 'hello'

      Py_BuildValue("ss","hello", "world") ('hello', 'world')

      Py_BuildValue("s#","hello", 4) 'hell'

      Py_BuildValue("()")()

      Py_BuildValue("(i)",123) (123,)     

      Py_BuildValue("(ii)",123, 456) (123, 456)

      Py_BuildValue("(i,i)",123, 456) (123, 456)

      Py_BuildValue("[i,i]",123, 456) [123, 456]      Py_BuildValue("{s:i,s:i}", "abc",123, "def", 456) {'abc': 123, 'def': 456}

      Py_BuildValue("((ii)(ii))(ii)", 1, 2, 3, 4, 5, 6) (((1, 2), (3, 4)), (5, 6))
================
Text
----------------
PyArg_ParseTuple函数 作用：此函数其实相当于sscanf(str,format,…),是Py_BuildValue的逆过程，这个函数将PyObject参数转换成C/C++数据类型，传递的是指针，但这个函数与Py_BuildValue有点不同，这个函数只能解析Tuple元组，而Py_BuildValue函数可以生成元组，列表，字典等。  原型：PyAPI_FUNC(int) PyArg_ParseTuple(PyObject *args, const char *format,...)
================
Code
----------------
Args:一般为Python程序返回的元组。
   
  Foramt:与Py_BulidValue类型，就不在累述咯。
   
  元组操作函数：
  因为程序之间传递的参数，大多数为Tuple类型，所以有专门的函数来操作元组：
   
  PyAPI_FUNC(PyObject *)PyTuple_New(Py_ssize_t size);
  解释：新建一个参数列表（调试了下，发现其实是用链表实现的），size列表为长度的宽度
   
  PyAPI_FUNC(Py_ssize_t)PyTuple_Size(PyObject *);
  解释：获取该列表的大小
   
  PyAPI_FUNC(PyObject *)PyTuple_GetItem(PyObject *, Py_ssize_t);
  解释：获取该列表某位置的值
   
  PyAPI_FUNC(int) PyTuple_SetItem(PyObject *,Py_ssize_t, PyObject *);
  解释：设置该列表此位置的值。如PyTuple_SetItem(pyParams,1,Py_BuildValue("i",2));设置第2个位置的值为2的整数。
================
Text
----------------
备注：对应的列表和字典也有对应的操作
更多的接口调用以及数据类型转化，参照Python文档
Python 调用C
Python调用C有两种方式
使用ctypes模块，Python文档有详细示例
使用C为Python编写拓展模块 Python之所以如此强大，正是由于可以使用C\C++为其编写拓展模块，手动编写拓展模块的方式稍微有些繁琐，可借用SWIG自动实现，简洁快速。更多详细的SWIG用法，见其官方文档 官网下载 windows包并解压
使用vs创建空项目，并配置vs。右键当前项目，选择属性  现在使用C为Python创建一个叫user的拓展模块，该模块包含一个showHello函数： 分别创建三个文件 user.i user.c user_wrap.c
在user.i中添加如下代码
================
Code
----------------
%module user
	
	%inline %{
	extern void showHello();
	%}
================
Text
----------------
user.c中添加
================
Code
----------------
#include <stdio.h>
	void showHello()
	{
		printf("hello Python!\n");
	}
================
Text
----------------
右键user.i 文件并选择属性  点击应用后如下图，完成配置  右键当前项目，选择属性，完成如下配置，确定  最后生成即可（选择工具栏 生成 --> 批生成）
创建测试代码调用C验证
================
Code
----------------
import user
user.show()
================
Text
----------------
在Linux下则无需如此麻烦的配置，可直接使用命令
================
Code
----------------
On Unix the compilation of examples is done using the file Example/Makefile. This makefile performs a manual module compilation which is platform specific. Typically, the steps look like this (Linux):

% swig -python interface.i
% gcc -fpic -c interface_wrap.c -I/usr/local/include/python1.5
% gcc -shared interface_wrap.o $(OBJS) -o interfacemodule.so 
% python
Python 1.5.2 (#3, Oct  9 1999, 22:09:34)  [GCC 2.95.1 19990816 (release)] on linux2
Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam
>>> import interface
>>> interface.blah(...)
================
Text
----------------
此处.i文件为SWIG的接口文件，其中%module后面定义模块名，用%inline定义方法列表
================
Code
----------------
%inline %{
包含导出的函数
%}
================
Text
----------------
有了Python与C的交互基础，则还需要Android中的NDK开发基础，关于Android平台的jni调用，本文不在此处详解，可看看我的JNI方面博客，而此处我们需要使用Crystax NDK开发工具链，非官方NDK工具链，需自行下载。下一篇正式涉及Python for Android。
================
Header
----------------
关注个人公众号：编程之路从0到1
================
Title
----------------
Python GUI之tkinter布局管理
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/53983812
================
Stars
----------------
181
================
Header
----------------
Python3 tkinter系列
================
Text
----------------
一、概述 二、布局管理 三、常用组件 四、实战（一） 五、实战（二） 六、进阶 自定义控件 推荐视频课程  tkinter从入门到实战
所谓布局，就是指控制窗体容器中各个控件（组件）的位置关系。tkinter 共有三种几何布局管理器，分别是：pack布局，grid布局，place布局。
pack布局 使用 pack布局，将向容器中添加组件，第一个添加的组件在最上方，然后是依次向下添加。
================
Code
----------------
from tkinter import *
 
root = Tk()
 
#创建三个 Label 分别添加到root窗体中 
#Label是一种用来显示文字或者图片的组件
Label(root,text = 'pack1',bg = 'red').pack() 
Label(root, text = 'pack2', bg = 'blue').pack() 
Label(root, text = 'pack3', bg = 'green').pack() 
 
root.mainloop()
================
Text
----------------
如图：
================
Header
----------------
pack常用属性
================
Code
----------------
from tkinter import *    #注意模块导入方式，否则代码会有差别
 
class App:
    def __init__(self, master):
        #使用Frame增加一层容器
        fm1 = Frame(master)
        #Button是一种按钮组件，与Label类似，只是多出了响应点击的功能
        Button(fm1, text='Top').pack(side=TOP, anchor=W, fill=X, expand=YES)
        Button(fm1, text='Center').pack(side=TOP, anchor=W, fill=X, expand=YES)
        Button(fm1, text='Bottom').pack(side=TOP, anchor=W, fill=X, expand=YES)
        fm1.pack(side=LEFT, fill=BOTH, expand=YES)
 
        fm2 = Frame(master)
        Button(fm2, text='Left').pack(side=LEFT)
        Button(fm2, text='This is the Center button').pack(side=LEFT)
        Button(fm2, text='Right').pack(side=LEFT)        
        fm2.pack(side=LEFT, padx=10)
 
        
root = Tk()
root.title("Pack - Example")
display = App(root)
root.mainloop()
================
Text
----------------
如上，创建一个Frame容器fm1，将三个垂直排列的Button组件使用pack布局放入fm1容器中，然后创建fm2容器，同样将三个水平排列的Button组件放入，最后将两个Frame容器当做组件，使用pack布局放入根窗体容器中。如此分层布局，实现了相对复杂一些的界面需求。
pack类提供了下列函数（使用组件实例对象调用）：
grid布局 grid布局又被称作网格布局，是最被推荐使用的布局。程序大多数都是矩形的界面，我们可以很容易把它划分为一个几行几列的网格，然后根据行号和列号，将组件放置于网格之中。使用grid 布局时，需要在里面指定两个参数，分别用row 表示行，column 表示列。需要注意的是 row 和 column 的序号都从0 开始。
如下图，假设将界面分成网格。
================
Header
----------------
grid属性设置
================
Text
----------------
grid类提供了下列函数（使用组件实例对象调用）：
place布局。 最简单最灵活的一种布局，使用组件坐标来放置组件的位置。但是不太推荐使用，在不同分辨率下，界面往往有较大差异。
================
Header
----------------
place属性设置
================
Text
----------------
place类提供了下列函数（使用组件实例对象调用）：
================
Header
----------------
关注个人公众号：编程之路从0到1
================
Title
----------------
给普通人的Python——第四章
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/yingshukun/article/details/86586459
================
Stars
----------------
3
================
Header
----------------
文章目录
================
Header
----------------
4. 写点有趣的程序：图形编程
================
Text
----------------
写这个系列的时候我就立了一个flag，要有趣！结果前面几天讲了很多基础知识，大家越看越乏味了，这也是没办法的，没有一点点基础知识，有趣的咱也玩不转不是。我知道很多人学编程都想写那种有界面可以鼠标点按的程序，但是我们离这个目标还稍微有一点点距离，今天我们学的这一篇就是打个前站，了解一点图形化程序开发的知识。
================
Header
----------------
4.1 画图基础
================
Text
----------------
我们先运行下面的代码看一下效果
================
Code
----------------
import turtle

window = turtle.Screen()
tt = turtle.Turtle()
tt.penup()
tt.goto(-100, 0)
tt.pendown()
tt.pencolor("red")

for i in range(4):
    tt.forward(200)
    tt.right(144)
tt.forward(200)

window.mainloop()
================
Text
----------------
运行示意图
没错，我们用Python代码画了一个五角星，这就是我们今天要学习的内容，使用Python画图。
为了适应不同基础的朋友，在正式学习代码之前，咱们得先复习一下英语
第1行代码import turtle，说明咱们画图需要先引入一个叫做“海龟”的模块。这个名字有一点莫名其妙，那么有人肯定要问了，为什么叫海龟呢？这是因为turtle绘图原理是这样的，假设有一只海龟，它正在窗口正中心，当它在画布上游动，所走过的轨迹就形成了绘制的图形。说白了，这就是turtle库作者的一个比喻，什么海龟不海龟的，其实就是指的画笔。我们所谓的画画，不就是拿笔在纸上面画线条么。
到这里我们先回忆一下生活中画画的场景，首先要支起一个画板，然后在画板上面铺上画布，最后拿起画笔沾颜料画画。我们用代码画图的时候，大致也是这么个过程，只要联系一下生活中的画画场景，就很容易理解代码。
让我们来一点点学习，首先运行下面的代码，会发现有一个窗口一闪而过
================
Code
----------------
import turtle

# 创建一个窗口对象，并赋值给变量window
window = turtle.Screen()

# 创建一个海龟对象，并赋值给变量tt
tt = turtle.Turtle()
================
Text
----------------
窗口一闪而过肯定是不行的，这时候我们需要在代码文件最后加一句window.mainloop()，实际上就是调用窗口对象的mainloop()函数，作用就是不让窗口立刻关闭。
再次运行下面的代码
================
Code
----------------
import turtle

# 创建一个窗口对象，并赋值给变量window
window = turtle.Screen()

# 创建一个海龟对象，并赋值给变量tt
tt = turtle.Turtle()

# 不让窗口立刻退出
window.mainloop()
================
Text
----------------
这里我们通过window = turtle.Screen()创建一个窗口对象，我们既然是图形程序，那肯定是需要有一个窗口的嘛。这里唯有一点要说明，这次我们调用turtle模块的Screen()函数是大写开头的，以后都要注意，创建对象的时候调用的是构造函数，函数名的首字母都是大写开头的，至于什么是对象，什么又是构造函数以后都会说明的，现在无需纠结啦，记得这回事就好。
接下来我们又通过Turtle()函数创建了一个“海龟对象”，并赋值给tt变量，我们看到窗口中有一个黑色的小三角箭头，这个就是我们的“海龟对象”，注意了，它是有朝向的哦，它默认朝向右侧。
好了，我们创建的窗口就是绘画中的画板了，它不仅是画板，而且还自带了画布呢，因此我们还省下了创建画布的过程，接着创建的“海龟”先生也就是我们的画笔了，更形象的说应该是“笔头”。到这里，万事具备只欠东风了，我们可以开始作画了！
学美术，画画之前要先学画线条，那我们就先画一条直线
================
Code
----------------
import turtle

# 创建一个窗口对象，并赋值给变量window
window = turtle.Screen()

# 创建一个海龟对象，并赋值给变量tt
tt = turtle.Turtle()

# 调用海龟对象的forward函数，向前移动200像素
tt.forward(200)

# 不让窗口立刻退出
window.mainloop()
================
Text
----------------
这里简单说一下像素这个单位，我们通常说的屏幕的分辨率就是其实就是指的像素，比如我们说的屏幕的分辨率1920x1080，其实就是指该屏幕宽有1920个像素，高有1080个像素。
这次让我稍微画复杂一点的，画一个直角
================
Code
----------------
import turtle

# 创建一个窗口对象，并赋值给变量window
window = turtle.Screen()

# 创建一个海龟对象，并赋值给变量tt
tt = turtle.Turtle()

# 调用海龟的forward函数，向前移动200像素
tt.forward(200)

# 抬起画笔
tt.penup()

# 调用backward函数，向后退200像素
tt.backward(200)

# 落下画笔
tt.pendown()

# 向左转90度
tt.left(90)

# 向前移动200像素
tt.forward(200)

# 不让窗口立刻退出
window.mainloop()
================
Text
----------------
上面代码的注释已经写得很详细了，penup、pendown这些函数名也都很好认，只有一点要说明，那就是只有当我们的画笔是落下状态时，向前或向后移动才能画出线条，而当我们调用penup()函数抬起画笔后，前后移动是不会画出线条的，而画笔默认就是落下的。
理解了之后，上面的都是小儿科了，下面我们接着学习，在之前的代码后面增加几行代码，我们再画一个圆
================
Code
----------------
import turtle

# 创建一个窗口对象，并赋值给变量window
window = turtle.Screen()

# 创建一个海龟对象，并赋值给变量tt
tt = turtle.Turtle()

# 调用海龟的forward函数，向前移动200像素
tt.forward(200)

# 抬起画笔
tt.penup()

# 调用backward函数，向后退200像素
tt.backward(200)

# 落下画笔
tt.pendown()

# 向左转90度
tt.left(90)

# 向前移动200像素
tt.forward(200)

# 将画笔复位到初始状态，也就是窗口正中心位置
tt.home()

# 设置画笔的粗细
tt.pensize(10)

# 设置画笔的颜色
tt.pencolor("yellow")

# 画圆弧，第一个参数为半径，第二个参数为弧度。360为整圆，180为半圆
tt.circle(100, 360)

# 不让窗口立刻退出
window.mainloop()
================
Text
----------------
这里就不放图了，大家运行之后看效果
最后，我们来说一下关于坐标体系的问题。我们初中数学就已经学过平面直角坐标系，这个相信大家都不陌生，在我们的turtle中，画笔默认出现的位置就是我们的坐标原点（0，0），也就是我们窗口的正中心，我们调用tt.home()其实就是让画笔回到坐标原点复位，且画笔的朝向也复位为朝右。这一点我们可以调用函数来验证
================
Code
----------------
import turtle

# 创建一个窗口对象，并赋值给变量window
window = turtle.Screen()

# 创建一个海龟对象，并赋值给变量tt
tt = turtle.Turtle()

# 调用pos函数，返回画笔当前的坐标点并打印输出
print(tt.pos())

# 不让窗口立刻退出
window.mainloop()
================
Text
----------------
输出结果：
================
Code
----------------
(0.00, 0.00)
================
Text
----------------
如上，我们调用画笔的pos()函数返回当前坐标点，这里pos就是position的缩写。可以看到，默认位置坐标正是原点。既然如此，那么我们想将画笔移动到任意坐标位置怎么办呢？这个时候，我们可以通过调用画笔的goto()函数做到，该函数可以传入两个参数，这是x、y的坐标值。这个函数在我们一开始绘制五角星的代码中使用过tt.goto(-100, 0)，这里要记得，如果我们只是想移动到指定的坐标位置，而不想画出线条，那么我们应该先调用penup()函数抬起画笔，当我们要画线时，则需要再调用pendown()落下画笔。
================
Header
----------------
4.2 深入用法
================
Text
----------------
这次我们写一个稍微深入一点的示例，画一个圆并给圆中填充绿色，除了画图，我们还学习一下文字的写法
================
Code
----------------
import turtle

# 创建一个窗口对象，并赋值给变量window
window = turtle.Screen()

# 创建一个海龟对象，并赋值给变量tt
tt = turtle.Turtle()

# 隐藏画笔的小箭头
tt.hideturtle()

# 写一行文字，并设置字体和字号
tt.write("人生苦短，我用Python", font=("华文行楷", 18))

# 抬起画笔
tt.penup()

# 移动画笔到（0，100）坐标处
tt.goto(0, 100)

# 放下画笔
tt.pendown()

# 设置填充色
tt.fillcolor("green")

# 开始填充
tt.begin_fill()

# 画一个圆
tt.circle(100, 360)

# 完成填充
tt.end_fill()

# 不让窗口立刻退出
window.mainloop()
================
Header
----------------
4.3 使用总结
================
Text
----------------
这里将上面代码中调用过的函数做一个总结，方便查看
================
Code
----------------
turtle
turtle
================
Text
----------------
剩下的的，就靠大家发挥创意，看怎么画出好玩的图像来，这里附两张网友作品给大家欣赏一下   附录：常用颜色 这里提供几种常见色值名，大家可以都试一试
================
Header
----------------
请关注公众号：编程之路从0到1
================
Text
----------------
只要关注，即可获取网盘资源！ 配合本教程，还有视频讲解哦，不容错过
================
Title
----------------
HDU - 4417 Super Mario  【主席树 】 询问区间中小于等于某个数的个数
================
License
----------------
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/Anxdada/article/details/81280922
================
Stars
----------------
2
================
Text
----------------
传送门  题目大意: 询问区间中小于等于某个数的个数
思路： 没什么好说的,,, 就是一个模板题, 会求区间第k大, 就会求这个.
================
Code
----------------
const int maxn = 1e5+5;
int n, m;
struct Tree {
    int ls, rs, val; // 左右儿子的编号, 和维护的一个值.
}tre[maxn*40];
int idx, root[maxn];
int build(int l, int r) {
    int nod = ++idx;
    tre[nod].val = 0;
    if (l == r) return nod;
    int mid = (l + r) >> 1;
    tre[nod].ls = build(l, mid);
    tre[nod].rs = build(mid+1, r);
    return nod;
}
int update(int pre, int l, int r, int pos, int v) {
    int nod = ++idx;
    tre[nod] = tre[pre]; tre[nod].val += v;
    if (l == r) return nod;
    int mid = (l + r) >> 1;
    if (pos <= mid) tre[nod].ls = update(tre[pre].ls, l, mid, pos, v);
    else tre[nod].rs = update(tre[pre].rs, mid+1, r, pos, v);
    return nod;
}
int query(int ql, int qr, int l, int r, int pos) {
    if (l == r) return tre[qr].val - tre[ql].val;
    int mid = (l + r) >> 1;
    int num = tre[tre[qr].ls].val - tre[tre[ql].ls].val;
    if (pos > mid) {
        return num + query(tre[ql].rs, tre[qr].rs, mid+1, r, pos);
    }
    else return query(tre[ql].ls, tre[qr].ls, l, mid, pos);
}
int a[maxn];
vector<int>ve;
int getid(int x) {
    return upper_bound(ve.begin(), ve.end(), x) - ve.begin();
}
void solve() {
    scanf("%d%d", &n, &m);
    ve.clear(); idx = 0;
    for (int i = 1 ; i <= n ; i ++) {
        scanf("%d", a+i);
        ve.pb(a[i]);
    }
    sort(ve.begin(), ve.end());
    ve.erase(unique(ve.begin(), ve.end()), ve.end());
    root[0] = build(1, sz(ve));    //根节点
    for (int i = 1 ; i <= n ; i ++) {
        int pos = getid(a[i]);
        root[i] = update(root[i-1], 1, sz(ve), pos, 1);
    }
    while (m--) {
        int l, r, k; scanf("%d%d%d", &l, &r, &k);
        ++l; ++r; int pos = getid(k);
        if (!pos) puts("0");
        else {int tmp = query(root[l-1], root[r], 1, sz(ve), pos);
        printf("%d\n", tmp);
        }
    }
}
================
Text
----------------
如果是求小于等于某个数的数字之和, 那么把次数1改成相应的权值val[i]即可呀, 一样的~~~
================
