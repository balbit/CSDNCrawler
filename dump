

Verilog 基础知识(一) Verilog 基础语法与注意事项

License

版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/jac_chao/article/details/123744724

Stars

405



基础知识
0.1 模块(Module)
Verilog中的module可以看成一个具有输入输出端口的黑盒子，该黑盒子有输入和输出接口(信号)，通过把输入在盒子中执行某些操作来实现某项功能。(类似于C语言中的函数)
图1 模块示意图
0.1.1 模块描述
图1 所示的顶层模块(top_module)结构用Verilog语言可描述为：



module  top_module(
    input a,
    input b,
    output out
);

   ....... 

endmodule



模块以module 开始，endmodule结束
top_module 为模块名
input : 为输入端口
output: 为输出端口
所有代码必须处于module模块中
同理，图1 所示的次级模块(mod_a)结构用Verilog语言可描述为：



module  top_module(
    input in1,
    input in2,
    output out
);

   ....... 

endmodule



注意事项
每个模应单独块处于一个.v文件中，模块名即为文件名
(规范代码！)
0.1.2 模块输入输出信号
输出： output
输入： input
模块的输入输出端口都可看出模块的信号，若不写信号类型则
默认为wire类型信号



// 以下这两个语句本质是一直的
input a;

input wire a;



除了wire型信号，还有reg型信号，具体详见
1.4
节！
0.1.3 模块实例化
如图1所示，top_module的两个输入端口连接到次级模块(mod_a)的输入端口，那如何在top_module模块模块中使用mod_a模块的功能呢？这就需要通过模块实例化，可以把top_module看成C语言中的主函数，次级模块mod_a看成普通函数，这样就可以在主函数中调用其他函数来完成相应的功能！
在top_module中实例化mod_a的方式为：
模块实例化语法
： 模块名 实例名(定义连接port的信号);



module  top_module(
    input a,
    input b,
    output out
);

	mod_a instance2 (.in1(a), .in2(b), .out(out));

endmodule



按mod_a定义的端口顺序实例化: mod_a instance1 (a, b, out);
按mod_a端口名实例化
: mod_a instance2 (.in1(a), .in2(b), .out(out)); (推荐此种写法)
0.2 逻辑块(always、generate)
0.2.1 always逻辑块
always块可构建 组合逻辑块 和 时序逻辑块，复杂的逻辑操作都需要处于该逻辑块中，如if、case、for等
(1) 组合逻辑块



module top_module();

    always @(*) begin
        ....
    end

endmodule



always逻辑块中
任意信号变化时立即触发
，执行begin - end之间的语句
begin - end用于
将多条语句组成一个代码块
，只有一条语句时可省略
(1) 时序逻辑电路



module top_module();

    always @(posedge clk) begin
        ....
    end

endmodule



clk
信号的上升沿触发
posedge: 上升沿
negedge: 下降沿
0.2.2 generate逻辑块
generate主要结合for循环使用，主要用途有：
向量
中的多个位进行重复操作
对同一个模块进行多次重复实例化
(主要用途)
(1) 操作向量



module top_module(input [7:0] in,  output [7:0] out);
    genvar i;        // genvar i; 也可以定义在generate内部
    generate
        for(i=0; i<8; i++) begin: bit
             assign out[i]=^in[8-1:i];
        end
    endgenerate
endmodule



(2) 模块重复多次实例化



module  top_module(
    input a,
    input b,
    output out
);
    genvar i;
    generate
        for(i=0; i<8; i++)  begin: gen_mod_a   //  gen_mod_a 为每个begin_end的结构的名称
            mod_a instance2 (.in1(a), .in2(b), .out(out));
        end
    endgenerate
endmodule



注意：模块多次实例化时
必须写每个begin_end结构的名称
(gen_mod_a)
仿真器会通过gen_mod_a来标识生成结构: gen_mod_a[0],gen_mod_a[1]....
0.2.3 initial块
initial块可以理解为一个
初始化块
，在initial的起始位置的语句
在0时刻即开始执行，之后如果遇到延时，则延时之后执行接下来的语句
初始块是
不可综合的
，因此
不能将其转化为带有数字元素的硬件原理图。因此初始块除了在仿真中使用外，并没有太大的作用
如:在仿真文件中初始化各种参数：



initial                                                
begin                                                  
    sys_clk    = 1'b1;                
    sys_rst_n  = 1'b0; 
	#50
	sys_rst_n  = 1'b1;                
end  



注意：
initial 块在电路中不可综合，故一般不出现在RTL代码中
initial 一般只在仿真文件中使用
若需要在RTL代码中初始化参数，需要用always块，用initial块会导致错误！
如下所示，
在RTL代码中初始化存储器的方式为



reg [255:0]char_data[4:0];

always@(posedge clk)
    begin
        char_data[0]     <=  256'h0000000000000000000000000000000000000000000000000000000000000000;
        char_data[1]     <=  256'h0000000000000000000000000000000000000000000000000000000000000000;
        char_data[2]     <=  256'h0000000000000000000000200000000000000000002000000008000010000000;
        char_data[3]     <=  256'h000000000000000000000038000000000000020000380000000600001C000000;
        char_data[4]     <=  256'h02000000000100000000003E0000000000000700003E0000000780001F000000;
    end



0.3 赋值方式
Verilog 中赋值方式有三种： 连续赋值、阻塞赋值、非阻塞赋值
0.3.1 连续赋值(assign)



assign x = y;



该语句表示把x和y两个信号进行连接，
真实的物理连接
不能在always块中使用
0.3.2 阻塞赋值(=)



// 组合块
always @(*)  begin
	out1 = a ;
    a = b ;
    out2 = a ;
end



组合always块中用阻塞式赋值
执行顺序：按照begin_end语句块中的
顺序依次执行
，上述输出结果为：out1 = a ，out2 = b
0.3.3 非阻塞赋值(<=)



// 时序块
always @(posedge clk)  begin
	out1 <= a ;
    a <= b ;
    out2 <= a ;
end



时序always块中用非阻塞赋值
执行顺序：begin_end中
所有语句并行执行
，上述输出结果为：out1 = a ，out2 = a
第一章 基础语法
1.1 标识符
(1)用途： 标识符用于定义常数、变量、信号、端口、参数名、模块名等。
(2)组成： 字母、数字、$、下划线任意组合而成
(3)注意事项：
区分大小写(Verilog 和 verilog是不同的)
第一个字符只能是字母或下划线
(123demo 是非法标识符)
1.2 逻辑值与逻辑运算
1.2.1 逻辑值
Verilog中有4中逻辑值：0、1、x、z
0: 低电平
1：高电平
x: 表示状态未知
z：表示高阻状态
注意：这里的z、x是
不区分大小写
的(X、Z也可)
1.2.2 逻辑运算
(1) 逻辑运算符：&&(与)、==（相等）、||（或）、!=（不等）
如 m&&n : 判断m和n是否全为真(
非0即为真
)，真则输出1'b1，否则输出1'b0 (4’b1010&4’b0101 =
1’b1
最后输出
结果只有1bit
(2) 按位运算符： &、|、~、^、~&、~^、~|
如 m&n : 是把m的每一位与n的每一位按位做与运算 (4’b1010&4’b0101 =
4’b0000
输出结果与m/n的bit数相同
(3) 归约运算符： &、|、~、^、&、~^、~|
只有一个参量参与运算时( &为一元运算符),表示规约与，即向量内部进行与运算



&a [3：0] // AND:a[3]&a[2]&a[1]&a [0]相当于(a[3：0]== 4'hf)
|b [3：0] // OR: b[3]|b[2]|b[1]|b [0]相当于(b[3：0]!= 4'h0)
^c [2：0] // XOR:c[2]^c[1]^c[0]



即(&4’b0101 = 0&1&0&1 =
1'b0
最后输出
结果只有1bit
1.3 常量的表示方法
与C语言类似，常量主要有：整数型、实数型和字符串型三种
1.3.1 用十进制整数表示整型常量
(1) 正数： 直接写 10 表示
位宽为32bit的十进制整数
(系统默认)
(2) 负数： -10需要用二进制补码表示，多了一位符号位(
1010)
(3) 用科学计数法表示：12.345e3 表示 12345
1.3.2 用基数法表示整数型常量



[换算成二进制数后的位宽]'[数制符号][与数制对应的值]



(1) 二进制(b): 8'b1000_1100
(2) 十六进制(h): 8'h8c
(3) 八进制(o): 8'o214
(4) 十进制(d): 8'140
注意事项：
当表示二进制时，最好每4位写一个下划线以增强可读性：如8'b1000
1100 与8'b10001100 是一样的
基数表示法中
遇到x时
：十六进制表示4个x，八进制中表示3个x
当位宽大于二进制位数时左边自动补0，小于二进制数时2从左边截断
1.3.3 字符串(用双引号)
(1)
每个字符
由1个8位的ASCII码值表示，即需要1byte存储空间
(2) 如：
“Hello world”
字符串由11个ASCII符号构成，需要11byte存储空间
1.3 注释方式
Verilog中注释主要有行注释(//)和块注释(/* .... */)两种，表示方法与C语言一致！



// 行注释

/*
        块注释

*/



1.4 变量(wire、reg)
Verilog中的变量主要有两种： wire和reg
1.4.1 wire
(1) 线网型(wire): 表示电路间的物理连接，wire定义的变量也可看成
信号端口
(2) 当两个wire信号被连续赋值时，在逻辑块中会被映射成真实的物理连线，
此时这两个信号端口的变化是同步的



wire a;

wire b;

assign b = a;    // 表示a与b之间生成实际的物理连线



1.4.2 reg
(1) 寄存器型(reg): 表示一个
抽象的数据存储单元
(2) reg 具有对某一时间点状态进行保持的功能
1.4.3 用法与注意事项
(1)
always、initial
语句中被赋值的变量(
赋值号左边的变量
)都是
reg
型变量
(2) 在
assign
语句中被赋值的变量，为
wire
型变量
1.5 向量(vector)与 参数(常量)
1.5.1 parameter 参数(常量)
(1) 参数是一种常量，通常出现在
module内部
，常被用于定义状态、数据位宽等



parameter STATE = 1'b0;



(2)
只作用于声明的那个文件，且可以被灵活改变
(3) 局部参数localparam，只在本模块中使用



localparam  STATE= 1'b1’;



(4) 参数的名称一般为
大写
，以区分其他变量
1.5.2 向量(vector)
vector(向量)，是
一组信号的集合
,可视为位宽超过1bit 的 wire 信号。
(1) 定义方式：



格式：input/output  wire/reg [upper:lower] vector_name

//输入输出型
input [7:0] a,b,
output reg [7:0] out

// 模块中间向量
wire [7:0] c, e;
reg [7:0] d;



[upper:lower] 定义位宽，如 [7:0] 表示位宽为8 bit ，即upper=7，lower=0
vector_name可以一次
写多个向量
1.5.3 向量片选
a[3:0] 取向量a的0~4位数据
b[n] 取向量b的第n位数据
c[-1:-2] 取向量c的最
低2位
数据
c[0:3] 取向量c的最
高4位
数据
多路选择器应用：实现一个 256 选 1 选择器，sel 信号作为选择信号，当 sel = 0 时选择 in[3:0]，sel = 1 时选择 in[7:4],以此类推。



module top_module (
	input [1023:0] in,
	input [7:0] sel,
	output [3:0] out
);
	assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};

	// assign out = in[sel*4 +: 4];		
	// assign out = in[sel*4+3 -: 4];	
endmodule



片选信号sel输入为n位二进制数，当
参与运算、充当索引
时会自动转换成十进制数
该题所选取的信号片段为: in[sel*4+3: sel*4] ,但这不符合Verilog的片选语法规则故应写成：
in[sel*4 +: 4]
表示索引从sel*4开始的
高4bit信号
in[sel*4+3 -: 4]
表示索引从sel*4+3开始的
低4bit信号
或是
直接选出需要的每一位
，再用{ }拼接成新向量：
{in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]}
参考文章：

Link

HDLBits：在线学习 Verilog （十三 · Problem 60-64） - 知乎 (zhihu.com)



1.6 三元表达式
(1) 与C语言相同，Verilog也有
三元表达式



condition ? if_true : if_false



当条件为真，表达式值为if_true ，否则表达式值为if_false。
(2) 应用



(sel ? b : a)   // 一个二选一MUX，通过sel的值选择a或者b

always @(posedge clk)         // 一个T触发器
  q <= toggle ? ~q : q;

assign out = ena ? q : 1'bz;  // 三态缓冲器



(3) 参考文章：

Link

HDLBits：在线学习Verilog（八 · Problem 35-39） - 知乎 (zhihu.com)



1.7 分支语句(if-else、case)
1.7.1 if-else语句
(1)
最常用的形式
：(优势：
输出的所有可能都写到，不存在未知电平输出
！)



if(<条件表达式 1>)
    语句或语句块 1;
else if(<条件表达式 2>)
    语句或语句块 2;
    ………
else
    语句或语句块 n;




(2) 不建议使用if-else嵌套，会存在优先级问题，导致逻辑混乱，
(3)
所有if-else语句都应写成(1)的形式
(4) 根据条件表达式依次比较，
存在优先级
1.7.2 case 语句
(1) 书写形式：



case(<控制表达式>)
    <分支语句 1> : 语句块 1;
    <分支语句 2> : 语句块 2;
    <分支语句 3> : 语句块 3;
    ………
    <分支语句 n> : 语句块 n;

    default : 语句块 n+1;
endcase




比较<控制表达式>与<分支语句n>的取值相等则执行对应语句，否则执行default后语句！
(2)
执行完某一分支语句后立即跳出case语句结构
，终止case语句执行。
(3)
<分支语句n>
的取值必须
互不相同
(4)
以encase结束
case语句块
(5) 各分支语句间
不存在优先级
(6) 具体应用: 用case语句搭建多路选择器，（以9选1多路选择器为例）



module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    always @(*) begin
        case(sel)
            4'h0:begin out = a; end
            4'h1:begin out = b; end
            4'h2:begin out = c; end
            4'h3:begin out = d; end
            4'h4:begin out = e; end
            4'h5:begin out = f; end
            4'h6:begin out = g; end
            4'h7:begin out = h; end
            4'h8:begin out = i; end
            default: out = 16'hffff;
        endcase
    end
endmodule



1.8 for循环语句
(1) 书写形式：



integer i;
always @(*)  begin 
    for(i=0; i<n; i++)  begin: for_name
        <循环语句>
    end
end



执行<循环语句>
n次
for_name为每一次循环的名称
1.9 关系运算符(>、<、>=、<=)
运算结果为真返回 1
运算结果为假返回 0
若某个操作
数值不定(x)
，则返回值为 x
2.0 拼接运算符({ , })
2.0.1 拼接
用一对花括号加逗号组成“
{ , }
”拼接运算符，逗号隔开的数据
按顺序拼接成新数据



wire [1:0] a;
wire [3:0] b;
wire [5:0] c;
wire [11:0] d = {a, b, c} 



2.0.2 通过拼接实现移位
在左边拼接实现右移，右边拼接实现左移！



always @(posedge clk) begin
    if(rst_n == 1'b0)
        out <= 4'b0;
    else
        out <= {in, out[3:1]};    // 右移
end



2.0.2 连接符中重复多次的操作
语法：
{重复次数{vector}}



{3{a}} = {a, a, a}
{3'd5, {2{3'd6}}}   // 9'b101_110_110.



2.1 移位运算符
移位运算符用于将左边操作数左移或右移指定的位数！
移位后空闲位用0填充
左移运算符： <<
如： 4‘b1101 << 3 结果为：4‘b1000
右移算法符: >>
如： 4‘b1101 >> 3 结果为：4‘b0001
移位运算符其他用途：
左移一位可以看成是乘以 2，右移一位可以看成是除以 2
移位运算符代替乘除法可以节省资源！
3 二进制全加器
a、b为输入 1bit 数据
cin为上一个加法器进位输入
cout为本加法器的进位输出
sum = a+b
代码实现：



module add1 (
	input a,
	input b,
	input cin,	
	output sum,
	output cout
);
	assign sum = a^b^cin;
	assign cout = (a&b) | (a&cin) | (b&cin);
endmodule



4 16进制全加器
16进制全加器如上图所示，它可由上节中16个二进制全加器组合而成。
用Verilog实现16进制全加器代码为：



module add16 (	
	input [15:0] a,
	input [15:0] b,
	input cin,
	
	output [15:0] sum,
	output cout
);
	wire [16:0] Add_cin;
	assign Add_cin[0] = cin;    // 上图中第一个二进制加法器进位输入为0 assign Add_cin[0] = 1b'0;

//  用 generate 进行模块多次实例化
// generate 应用范围：对矢量(vector)多个位重复操作，模块重复实例化
	genvar i;
	generate
		for(i=0; i<16; i++) begin: gen_add16		// gen_add16 为每个begin_end的结构，仿真器会通过他来标识生成结构，gen_add16[0],gen_add16[1]....
			add1 Add16(.a(a[i]), .b(b[i]), .cin(Add_cin[i]), .sum(sum[i]), .cout(Add_cin[i+1]));
		end
	
	endgenerate
	
	assign cout = Add_cin[16];

endmodule



5 模块中的参数传递
5.1 定义可传递参数的模块



module counter
// 参数传递
#(
    parameter COUNT_MAX = 25'd24_999_999,
    parameter STATE     = 1'b0            // 多个参数用逗号隔开
)
(
    input  wire  sys_clk,
    output reg led_out
);
// 代码主体
endmodule



5.2 带参数模块的实例化



// 参数传递
#(
   .COUNT_NUM( 25'd24_999_999),        // 传入参数
   .STATE(1'b0)
)
counter1_init      // 实例化模块的名称位置
(
    .sys_clk   (sys_clk),
    .led_out(led_out)
); 



参考资料：
[1] 野火《FPGA Verilog开发实战指南》：
[野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Pro开发板 — [野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Pro开发板 文档 (embedfire.com)
https://doc.embedfire.com/fpga/altera/ep4ce10_pro/zh/latest/index.html
[2] HDLBits中文导学：

Link

HDLBits 中文导学 - 知乎 (zhihu.com)



FPGA语法篇——Verilog 语法知识

License

版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/lgyLGY35/article/details/113930618

Stars

68



Verilog语法
目录

Link

Verilog语法

Link

一、Verilog基础知识

Link

逻辑值

Link

数字进制

Link

标识符

Link

数据类型

Link

寄存器类型

Link

线网类型

Link

参数类型

Link

运算符

Link

二、Verilog程序框架

Link

Verilog注释

Link

Verilog关键字

Link

Verilog程序框架

Link

模块调用、例化——模块化设计

Link

三、Verilog高级知识点

Link

结构语句

Link

initial与always

Link

赋值语句

Link

阻塞赋值（Blocking）

Link

非阻塞赋值（Non-Blocking）

Link

总结

Link

assign 和 always 区别

Link

条件语句

Link

if_else语句：

Link

case语句：

Link

latch锁存器

Link

四、Verilog状态机FSM

Link

状态机FSM概念

Link

状态机模型

Link

Mealy状态机（输出=输入+之前状态）

Link

Moore 状态机（输出=之前状态）

Link

状态机设计

Link

1.状态空间定义

Link

2.状态跳转（时序逻辑）

Link

3.下一个状态的判断（组合逻辑）

Link

4.各个状态下的动作（组合逻辑）

Link

总结



一、Verilog基础知识
逻辑值
0、1、X（未知）、Z（高阻态）
数字进制
二进制：4’b0101 表示 4 位二进制数字 0101；
十进制：4’d2 表示 4 位十进制数字 2（二进制 0010）；
十六进制：4’ha 表示 4 位十六进制数字 a（二进制 1010）
当代码中没有指定数字的位宽与进制时，默认为 32 位的十进制，比如 100，实际上表示的值为 32’d100。
标识符
用于定义模块名，端口名，信号名，由字母、数字、$和_(下划线)组成，第一个字符必须是字母或者下划线，区分大小写。
不建议大小写混合使用，普通内部信号建议全部小写，参数定义建议大写。
采用一些前缀或后缀，比如：时钟采用 clk 前缀：clk_50m，clk_cpu；低电平采用_n 缀：enable_n；
数据类型
寄存器类型、线网类型和参数类型。



寄存器类型



是一个数据存储单元，常用 reg 类型，默认初始值为X（未知）。
//reg define




reg 



31



 delay_cut



//32位寄存器




reg        key_reg



//默认位宽为 1
只能在 always 语句和 initial 语句中被赋值。（不允许像C语言一样，在定义同时赋值）
如果该过程语句描述的是时序逻辑，即 always 语句带有时钟信号，则该寄存器变量对应为寄存器；
如果该过程语句描述的是组合逻辑，即 always 语句不带有时钟信号，则该寄存器变量对应为硬件连线。



线网类型



表示结构化实体（e.g.门）的物理连线。不能存储值，它的值由驱动它的元件决定。驱动元件有连续赋值、门、assign等。默认是Z高阻态。 有tri 和 wire型。
//wire define




wire data_en



//数据使能信号




wire 



 data 



//数据



参数类型



参数其实就是一个常量，用parameter定义（类似C语言中的define）我们可以一次定义多个参数，参数与参数之间需要用逗号隔开。参数的定义是局部的，只在当前模块中有效。
//parameter define




parameter DATA_WIDTH 



//数据位宽为8位
//可以[DATA_WIDTH : 0]只修改参数值来修改位宽
参数型数据用于定义状态机的状态、数据位宽和延迟大小等，在模块调用时可以通过参数传递来改变调用模块中已定义的参数。
运算符
算术运算符：
Verilog 实现乘除比较浪费组合逻辑资源，尤其是除法。所以 2 的指数次幂的乘除习惯用移位，非 2 的指数次幂的乘除调用现成的 IP（ISE提供）
关系运算符
逻辑运算符：
！、&& 、 ||
条件操作符：
a ? b : c
位运算符：
~（取反）、&、 |、^（异或）
移位运算符：
<< a << b 将 a 左移 b 位
左移时位宽增加，右移时位宽不变。
4‘b1001 <<2 = 6’b100100
拼接运算符：
{a,b} 将 a 和 b 拼接起来作为一个新信号。
二、Verilog程序框架
Verilog注释
//与/* */
Verilog关键字
关键字
含义
module
模块开始定义
input
输入端口定义
output
输出端口定义
inout
双向端口定义
parameter
信号的参数定义
wire
wire信号定义
reg
reg信号定义
always
产生reg信号语句的关键字
assign
产生wire信号语句的关键字
begin
语句的起始标志
end
语句的结束标志
posedge/negedge
时序电路的标志
case
Case语句起始标记
default
Case语句的默认分支标志
endcase
Case语句结束标记
endmodule
模块结束定义
Verilog程序框架
基本设计单元是模块（Block），类比C语言中的函数。
模块由两部分组成，一部分描述接口，一部分描述逻辑功能，
每个Veirlog程序包括端口定义、IO说明、内部信号说明、功能定义。下面以程序示例讲解知识点。
// 模块名(端口定义);




module 



block
//IO说明




	input a




	output c



/************************************************ 1.未说明类型就是wire类型，reg类型定义为： output reg [3:0] led //在位宽之前加reg 2.端口定义和IO说明可以放在一起,例如 module led( input sys_clk , //系统时钟 input sys_rst_n, //系统复位，低电平有效 output reg [3:0] led //4 位 LED 灯 ); ************************************************/
//内部信号说明就是只在此模块内部使用的一些信号，不是输入输出
/************************************************ 功能定义：3种方法： assign描述组合逻辑 always描述组合/时序逻辑 例化示例元件 例如 and #2 u1(q,a,b) 3种逻辑功能是并行的 ************************************************/
//assign 给wire类型赋值




	assign c 




	assign d 




endmodule




模块调用、例化——模块化设计



Verilog 语法中的模块例化。FPGA 逻辑设计中通常是一个大的模块中包含了一个或多个功能子模块，Verilog 通过模块调用或模块实例化来实现这些子模块与高层模块的连接。【把系统划分为几个模块，每个模块对应一个module，
一个module一个Verilog程序文件
。顶层模块只做例化（调用其它模块），不做逻辑。】
首先将被调用模块例化，例化模块名加u_
//顶层模块




module seg_led_static_top 



 
	input sys_clk 



// 系统时钟




 	 input sys_rst_n



// 系统复位信号（低有效）




 	 output 



 seg_sel 



// 数码管位选




 	 output 



 seg_led 



// 数码管段选
//parameter define




 	 parameter TIME_SHOW 



25



'd25000_000



// 数码管变化的时间间隔 0.5s
//wire define




 	 wire flag



// 数码管变化的通知信号
//每隔 0.5s 产生一个时钟周期的脉冲信号




time_count #



MAX_NUM 



TIME_SHOW



//参数TIME_SHOW控制数码管每隔多长时间改变显示的数值，底层代码给参数MAX_NUM了值，此处也是一种参数赋值方式，就是把TIME_SHOW的值给MAX_NUM
u_time_count
//例化模块名加_u



clk 



sys_clk 



//由模块代码看以看到clk是模块的输入



rst_n 



sys_rst_n



//所以这就是把上层模块的信号输入到底层模块，这里（）里可以是wire或者reg，而下面的output的连接必须是wire型的



flag 



flag 



//而底层模块的输出信号是连接到了上层模块中定义的其他变量
//信号传递的时候信号的位宽必须一致
//属于底层文件
//计时模块代码




 module 



time_count



 
 	input clk 



// 时钟信号




 	input rst_n 



// 复位信号




	output reg flag 



// 一个时钟周期的脉冲信号





parameter MAX_NUM 



25000



_000



// 计数器最大计数值




reg 



24



 cnt



// 时钟分频计数器
三、Verilog高级知识点
结构语句



initial与always



initial：
只执行一次，立即执行，用于tb文件编写，产生激励信号或对reg变量赋初值。



initial begin
	sys_clk          



<=



b'




	touch_key        



<=



b'



10



 touch_key    



<=



b'




end




always：
一直执行，但需要结合一定的时间控制才有作用
always的时间控制可以是电平触发也可是边沿触发。可以是单个信号也可以是多个信号，多个信号用or连接
/**************边沿触发(时序逻辑行为)**************/
//用于产生 0.5 秒使能信号的计数器
//@()里的多个事件名或信号名组成的列表叫做敏感列表，只有满足敏感列表才能执行后面的语句




always @



posedge sys_clk 



or



 negedge sys_rst_n



 begin
 



if



sys_rst_n 



==



'b0



 
 	counter 



<=



'b0



else
if



counter_en




 	counter 



<=



'b0



else




 	counter 



<=



 counter 



'b1




end





/**************电平触发(组合逻辑行为)**************/




always @



or
or
or
or



 begin
	out1 




end




//如果输入变量很多，敏感列表就很长且易错




always @



 begin  



//表示后面语句块中所有输入变量都是敏感的




	out1 




end




赋值语句
分为阻塞赋值和非阻塞赋值；RHS（Right hand side）是赋值符号右侧信号， LHS是左侧



阻塞赋值（Blocking）



b = a;
计算 RHS 的值并更新 LHS。
在一个 always 块中，后面的赋值语句是在前一句赋值语句结束后才开始赋值的。即 always 块内的语句是一种顺序关系。



非阻塞赋值（Non-Blocking）



b <= a;
（1）赋值开始的时候，计算 RHS；
（2）赋值结束的时候，更新 LHS。
在计算非阻塞赋值的 RHS 以及 LHS 期间，允许其它的非阻塞赋值语句同时计算 RHS 和更新 LHS。
非阻塞赋值只能用于对寄存器类型的变量进行赋值，因此只能用在initial和always块等过程块中。
需要注意的是赋值语句是一直在always中执行，所以随着clk的上升沿一直来，bc最后也都变成a =0;
总结
1.描述组合逻辑电路
，用阻塞赋值，比如 assign 赋值语句和不带时钟的 always 赋值语句，这种电路结构只与输入电平的变化有关系
2.描述时序逻辑电路
，用非阻塞赋值，综合成时序逻辑的电路结构，比如 带时钟的 always 语句；这种电路结构往往与触发沿有关系，只有在触发沿时才可能发生赋值的变化
注意 ：
同一个always中不要既用阻塞又用非阻塞
不允许在多个always中对同一个变量赋值（因为并行执行）
assign 和 always 区别
assign 不能带时钟。 always 可以带也可以不带。在 always 不带时钟时，逻辑功能和 assign 完全一致，都只产生组合逻辑。比较简单的组合逻辑推荐使用 assign 语句，比较复杂的组合逻辑推荐使用 always 语句。



 assign counter_en 



counter 



==



COUNT_MAX 



'b1)) ? 1'



b1 



'b0



 
 always @



 begin
 		



case



led_ctrl_cnt



'd0 : led = 4'



b0001



51
'd1 : led = 4'



b0010



'd2 : led = 4'



b0100



'd3 : led = 4'



b1000



54
default



 led 



'b0000



	
		endcase
end




条件语句



if_else语句：



1.必须在过程块（有initial和always语句引导的）中使用
2.表达式值为X,Z时按假处理
3.if之后如果多句，要用begin end
4.不允许if嵌套



case语句：



与C中的case不同，没有switch关键字。
case



curr_st



'h0



 next_st 



 S1



'h1



 next_st 



 S2



'h2



 next_st 



 S3



'h3



 next_st 



 S4



default



 next_st 



 S0




	 endcase




1.所有表达式的位宽必须相等，不能用’bx代替n’bx，
2.casez：比较时不考虑z
casex：比较时不考虑z和x



reg 



 sel



//1100_0011
casez



sel



//这种就不用考虑下面表达式中的高阻值



'b1100_zzzz



语句



'b1100_xxzz



语句



//xx与00不相等，所以执行语句1




endcase





casex



sel



此时两个表达式相当于相同了，error！





latch锁存器



锁存器是电平触发的存储器，是组合逻辑产生的，寄存器是边沿触发的存储器，在时序电路中使用，由时钟触发产生的。
if 缺少 else 分支，case 缺少 default
分支会导致代码在综合过程中出现了 latch。latch只在组合逻辑电路中产生，也就是只有不带时钟的 always 语句中 if 或者 case 语句不完整才会产生 latch，带时钟的语句 if或者 case 语句不完整描述不会产生 latch。
四、Verilog状态机FSM
状态机FSM概念
我们一直在强调硬件描述语言是并行执行的，所以如果按顺序流程来完成一个操作的时候，就需要很多的if_else，降低了代码的可读性，也让代码编写难度增加（与单片机编写程序的区分）。所以就需要引入状态机，将一项功能的完成分解为若干步，每一步对应于二进制的一个状态，通过预先设计的顺序在各状态之间进行转换，状态转换的过程就是实现逻辑功能的过程，就像数电里学过的画状态转换图/表。
状态机，（Finite State Machine，FSM有限状态机）一种在有限个状态之间按一定规律转换的时序电路，是组合逻辑和时序逻辑的组合。
状态机模型



Mealy状态机（输出=输入+之前状态）



F 是当前状态和输入信号的函数，状态是否改变、如何改变，取决于组合逻辑 F 的输出；
状态寄存器，其由一组触发器组成，用来记忆状态机当前所处的状态，状态的改变只发生在时钟的跳边沿；
状态机的输出是由输出组合逻辑 G 提供的，G 也是当前状态和输入信号的函数。



Moore 状态机（输出=之前状态）



Moore型不是没有输入，而是输出与输入无关。
状态机设计
四段论：
状态空间定义；
状态跳转；
下个状态判断；
各个状态下的动作；



1.状态空间定义



/************************方法1：************************/
//state space




parameter S0 



'b00




parameter S1 



'b01




parameter S2 



'b10




parameter S3 



'b11



// internal varialbe




reg 



 current_state




reg 



 next_state



/************************方法2：推荐************************/
//独热码：每个状态只有一个寄存器置位，译码逻辑简单
//state space




parameter S0 



'b1000




parameter S1 



'b0100




parameter S2 



'b0010




parameter S3 



'b0001



// internal varialbe




reg 



 current_state




reg 



 next_state



2.状态跳转（时序逻辑）



就是上面框图中的状态寄存器



always @



posedge clk 



or



 negedge rst_n



 begin
	



if



rst_n




		current_state 



<=



 S0



else




		current_state 



<=



 S1



3.下一个状态的判断（组合逻辑）



就是上面框图中的产生下一状态的组合逻辑F



always @



current_state  



or



 input signals



 begin
	



case



current_state 



//强烈建议使用case 而不用if_else




		S0



 begin
			



if




				next_state 



 S1



else



 
				next_state 



 S0




		S1




		S2




		S3



default




	endcase
end




4.各个状态下的动作（组合逻辑）



就是上面框图中的产生输出的组合逻辑G
//action




wire qook




assign qook 



current_state 



==



 S1



'b1 : 1'



b0



//下面是用always写上面的语句




always @



current_state 



 begin
	



if



current_state 



==



 S1




		qook 



else



 
		qook 




end




总结



这里我们实际用了一个三段式状态机。基本格式是：
第一个 always 语句实现同步状态跳转；
第二个 always 语句采用组合逻辑判断状态转移条件；
第三个 always 语句描述状态输出(可以用组合电路输出，也可以时序电路输出)。
可以在组合逻辑之后再加一级寄存器实现时序逻辑输出
1.滤除组合逻辑输出的尖峰脉冲
2.进行时序计算和约束
3.对于总线形式的输出信号来说，容易使总线数据对齐，减小总线数据间的偏移，减小接收数据采样出错的频率。比如8位位宽信号，如果用组合逻辑，可能导致并行的8个数据从输入端到达输出端的时间不一致。

